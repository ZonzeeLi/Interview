# 数据库知识

## MySQL

#### 1. 索引的类型

- 普通索引：最基本的索引，没有任何约束。

- 唯一索引：与普通索引类似，但具有唯一性约束。

- 主键索引：特殊的唯一索引，不允许有空值。

- 复合索引：将多个列组合在一起创建索引，可以覆盖多个列。

- 外键索引：只有InnoDB类型的表才可以使用外键索引，保证数据的一致性、完整性和实现级联操作。

- 全文索引：MySQL 自带的全文索引只能用于 InnoDB、MyISAM ，并且只能对英文进行全文检索，一般使用全文索引引擎。

#### 2. 100w条数据  每一条都要查一下数据库，请问多线程查询和单线程查询时间一样吗？

如果是mysql的话一定程度上多线程可以优化查询时间，读锁是共享锁，多线程可以共享该锁进行读取。

## Redis

#### 1. 如果订阅端挂了怎么办？如果发布的数据过多处理不过来怎么做？如果重复发布怎么办？

#### 2. 缓存中的淘汰策略

1. 定时去清理过期的缓存。
2. 当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。

两者各有优劣，第一种的缺点是维护大量缓存的 key 是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂。具体用哪种方案，大家可以根据自己的应用场景来权衡。

- volatile-lru：从已设置过期时间的key中挑选最近最少使用的数据淘汰；

- volatile-ttl：从已设置过期时间的key中挑选将要过期的数据淘汰；

- volatile-random：从已设置过期时间的key中任意选择数据淘汰；

- volatile-lfu：从已设置过期时间的key中挑选使用频率最低的数据淘汰；

- allkeys-lru：从key中挑选最近最少使用的数据淘汰；

- allkeys-lfu：从key中挑选使用频率最低的数据淘汰；

- allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰；

- no-enviction（驱逐）

#### 3. 缓存击穿、穿透、雪崩及解决方案

- 击穿

当某个key在某一刻失效，且正好该时刻存在大量的并发请求来访问该key的值，但该key已经不存在，导致查不到的现象。重点是缓冲中没有，但是数据库存在

解决方案

1、缓冲没有的时候，加锁，获取到锁的线程，从数据库取值后set到缓冲，没获取到锁的线程，则先睡眠短暂时间，然后从缓冲取，直接返回。
2、设置热点数据永不过期。

- 穿透

当某个key在某一时刻实现，且正好该时刻存在大量的并发请求来访问该key，该key不存在，则大量的请求来访问数据库，但是数据库也不存在，导致请求都会查询redis和数据库的现象，缓冲中和数据库中都没有，恶性攻击，可以利用这一点，通过脚本大量的发送请求，是你的数据库奔溃。

解决方案

加锁，并且如果数据库不存在，则设置空值，后来的请求拿到空值后，可以判断数据库也没有，则直接返回。

- 雪崩

在某个时间大量的key失效，且正好在该时刻存在大量的请求来访问这些实效的key，导致大量的请求打到数据库的现象。

解决方案

采用版本号，提前更新或者在一定范围随机设置key的实效时间，将失效时间打散。