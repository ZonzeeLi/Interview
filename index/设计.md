# 设计

## 场景设计

### 1. 订单30分钟未支付自动取消怎么实现？

1. 数据库轮询。使用一个线程定时的去扫描数据库，通过订单时间来判断是否有超时的订单，然后进行取消操作。缺点是存在延迟，比如每隔5分钟扫描一次，那最差的延迟时间就是5分钟，而且如果订单量非常大的，每隔几分钟扫描一次对数据库的性能消耗极大。
2. JDK的延迟队列。
3. 使用Redis的Keyspace Notifications。在key失效后提供一个回调（实际上是Redis会给客户端发送一个消息），生成订单的时候把订单号存入Redis作为key，按订单的有效时间设置失效时间，当监听到键失效的时候就可以执行代码将订单标记为过期。
4. 使用消息队列。使用RabbitMQ模拟延时队列的功能，RabbitMQ具有以下两个特性，可以实现延迟队列。RabbitMQ可以针对Queue和Messsage设置x-message-tt，来控制消息的生存时间，如果超时，则消息变为死信，可以配置x-dead-letter-exchange和x-dead-letter-routing-key两个参数，用来控制队列内出现了死信的时候，按照这两个参数重新路由，基于以上两个特性可以模拟出延迟消息的功能。此方案的优点是高效，容易进行横向扩展，消息支持持久化，增加了可靠性，缺点是引入了RabbitMQ，复杂度和成本都高。

### 2. 如何把一个文件较快的发送到100w个服务器？

1. 可以采用p2p网络形式，比如树状形式。单个节点既可以从其他节点接受服务又可以向其他节点提供服务。但树状结构存在以下问题：第一，如果树上的某一个节点坏掉，那么这个节点往下的服务器全都接收不到文件；第二，如果树上的某个路径，因为网络因素等原因，传递速度比较慢，导致传递时间比较长，这样会使传递效率退化。
2. 使用连通图。100w台服务器相当于有100w个节点的连通图，可以在图里生成多颗不同的生成树，在进行数据下发时，同时按照多颗不同的树去传递数据，这样就可以避免某个中间节点宕机，影响到后续的节点，同时这种传递方法实际是一种一句时间的广度优先遍历，可以避免某条路经过长造成的效率低下。