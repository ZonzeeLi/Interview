# 垃圾回收

## 常见的 GC 算法

### 引用计数法

引用计数法会为程序中的每个对象在对象头中分配一个空间来保存该对象被引用的次数，如果有其他对象引用了该对象，那么它的引用计数加 1。如果其他对象删除了对该对象的引用，则它的引用计数减 1，当该对象的引用计数为 0 时，此时没用任何引用，就可以被回收。

#### 优点

简单直接，回收速度快，不会出现内存耗尽或达到某个阈值时才回收。

#### 缺点

不能很好的处理循环引用，而且需要有额外的空间实时维护引用计数，也有一定的代价

![Go引用计数法缺点](../image/Go引用计数法缺点.png)

比如上图，在删除了对象 A 和 D 之后，由于对象 B 和 E 之间存在循环引用，所以上下 B、C、E、F 四个对象都存在引用关系，计数都不为 0，所以不能被回收，如果大量存在这种循环对象，就会造成一定的内存泄漏。

### 标记清除法

标记清除算法主要分为两个阶段：

标记阶段：遍历所有活动对象，并标记那些还在使用的对象标签。

清除阶段：遍历内存中所有对象，清除那些没有被标记的对象。

![Go标记清除法](../image/Go标记清除法.png)

#### 优点

简单易实现，不需要额外的数据接口，只需遍历一次对象图即可完成标记和清除操作，适合可回收对象不多的场景。

#### 缺点

主要是会造成内存碎片，导致后续需要创建大对象的时候，由于没有连续的足够大的内存空间而创建不了，降低了内存的使用率。

### 复制法

复制算法将内存分成两个相等的区域，并且一次只使用其中一个。当这个区域被用完时，程序会把所有还在使用的对象复制到另一个空区域（保留区域），然后将已使用的区域全部清除。这样，每次只需对一个区域进行垃圾回收，分配内存时也无需处理碎片问题，只需按顺序移动指针进行分配。

![Go复制法1](../image/Go复制法1.png)

![Go复制法2](../image/Go复制法2.png)

#### 优点

主要是避免了内存碎片问题，每次清除针对的都是整块内存。

#### 缺点

内存利用率低，使用的内存会缩小为原来的一半。如果存活的对象很多，将这些对象都复制一遍，并且更新它们的应用地址，这一过程耗时可能较长，回收效率不够高。

### 分代法

分代收集算法可以被视为上述内容的扩展。它的实现思路是根据对象生命周期的差异，将内存划分为多个区域，例如将堆空间划分为新生代和老年代，然后根据每个区域的特点选择最合适的收集算法。

在新生代中，由于存在大量对象很快被销毁、少量对象存活的特点，通常使用“复制算法”。这种算法只需付出少量存活对象的复制成本就可以完成垃圾对象的收集，效率非常高。而在老年代中，由于对象的存活率高，且没有额外空间进行分配担保，通常使用“标记-清理”或“标记-整理”算法来进行回收。

## Go 语言 GC 算法

### 为什么 go 语言 gc 不选择分代与标记整理

1. go 为什么没有选用标记整理或者复制？

标记整理算法或者复制算法主要是为了减少内存碎片，然而，Go 运行时使用的内存分配算法是基于 tcmalloc，虽然不能像复制算法那样消除掉内存碎片化的问题，但也极大地降低了碎片率，所以标记整理显得有时并不是那么明显，并且 Thread Cache 的分配机制使得 Go 在大多数分配场景下可以避免使用锁，从而在高并发情况下展现出强大的性能优势。

2. go 为什么没有选择分代？

go 语言的 struct 类型创建是可以分配到栈上的，而不是像 java 一样 new 出来的对象在堆上。go 会在编译期做静态逃逸分析，可以将生命周期很短的对象直接安排在栈上分配（比如函数内未发生的逃逸的 struct 类型变量），分代 GC 最大的优势就是可以区分长生命周期和短生命周期对象，从而快速回收生命周期短的对象，但是由于 go 语言在编译期会做逃逸分析，所以 go 语言中的短生命周期对象并没有那么多，使得分代 GC 在 go 语言中受益并不明显。此外，分代 GC 还需要额外的写屏障来维护老年代对新年代的引用关系，这也增加了 GC 的开销。

## Go 语言 GC 的主要发展过程

go 语言也不是一开始就是使用的并发三色标记法（GC 程序与用户代码并发执行）加上屏障技术来实现，其主要经历以下三个过程：

- V1.3 及之前：标记清除算法
- V1.5：三色并发标记法
- V1.8：混合写屏障机制

### 什么样的内存 GC 不能回收？

举个例子

```go
type Student struct {
	Name string
	Age  int
}

func main() {
	slice := make([]Student, 6)
	slice = slice[:3]
	fmt.Println(slice)
}
```

程序创建了一个 Student 类型的切片 slice，包含 6 个元素，当 slice 发生缩小，大小缩为原来的一半，只有 3 个元素的时候，底层数组的另外 3 个元素已经无法再访问了。但是堆上的内存是不会被 GC 的，因为根据标记清理方法从根节点开始标记的话，这块内存还是属于可达的，所以不会被 GC 掉。同样的情况还存在于 Map 中，当创建一个 Map 之后，delete 掉 Map 中的某个 key 之后，对应部分的内存也是不会被 GC 的。

### 标记清除算法

从前面标记算法可知，标记清除算法，包括标记和清除两个阶段：

标记阶段：从根对象开始，查找并标记堆中所有存活的对象。

清除阶段：遍历堆中所有对象，回收未被标记的对象。

假设程序开始阶段对象分布如下图所示，下面用图示的方法展示标记清除的过程：

![Go标记清除法过程1](../image/Go标记清除法过程1.png)

1. 从根对象开始，逐一遍历每个对象及其子对象，并标记它们的可达状态，如下图所示：

![Go标记清除法过程2](../image/Go标记清除法过程2.png)

- 可达对象：对象 A，对象 B，对象 C，对象 D，对象 F，对象 G，对象 H
- 不可达对象：对象 E

2. 遍历堆上的所有对象，回收没有被标记的不可达对象，如下图所示：

![Go标记清除法过程3](../image/Go标记清除法过程3.png)

清除完成之后，剩下可达对象 A、B、C、D、F、G、H，不可达对象 E 被清除，内存释放。

注意：以上只是回收器（GC程序）的工作过程，还没有考虑赋值器（用户程序），其实回收器在进行标记和清扫的过程中是要暂停整个用户程序的，暂停整个用户程序也称作 STW。

> 如果不 STW，会出现什么情况？
> 假设现在标记阶段已经完成，对象 A、B、C、D、F、G、H 被打上标记，而对象 E 是未被标记的准备回收的对象，就在此时，清除之前对象 H 又指向了对象 E。

![Go标记清除法过程4](../image/Go标记清除法过程4.png)

> 那么接下来回收器就会将对象 E 错误删除，其实对象 E 此时已经是可达对象了，是存在引用关系，再被使用的，是不能被 GC 的，所以完整的标记清除算法需要在进行 GC 前进行 STW，即暂停整个用户程序。这样的话，性能必然很低，很难有人可以接受这种性能损耗。

### 三色标记法

简单的标记清除算法会带来长时间的 STW，为了解决这个问题，Go 语言在 V1.5 版本，使用三色并发标记法来优化这个问题。三色标记法将程序中的对象分为三类：白色、灰色和黑色：

- 白色：未被垃圾收集器访问到的对象，也就是潜在的垃圾对象。在回收开始阶段，所有对象都标记为白色；在回收结束后，所有白色对象均不可达，其内存将被释放。
- 灰色：已被垃圾收集器访问到的对象，但是垃圾收集器需要继续扫描它们的子对象，因为其可能存在指向白色对象的外部指针。
- 黑色：已被垃圾收集器访问到的对象，且其引用都已被扫描到，黑色对象中任何一个指针都不可能直接指向白色对象。

标记过程如下：

1. 初始状态：所有对象都是白色的。
2. 扫描根对象：从根对象开始扫描，将所有可达对象标记为灰色，并放入待处理集合中。
3. 处理灰色对象：从待处理集合中取出灰色对象，将它们引用的对象标记为灰色，并将这些新标记的对象加入待处理集合中，同时将自身标记为黑色。
4. 重复扫描：重复第 3 步，直到待处理集合为空。此时，所有白色对象都是不可达的垃圾对象，可以进行回收。

假设应用程序中的对象关系如下图所示，下面用图示的方式展示三色标记的过程：

![Go三色标记法过程1](../image/Go三色标记法过程1.png)

1. 应用程序开始运行时，所有对象默认标记为白色，如下图所示：

![Go三色标记法过程2](../image/Go三色标记法过程2.png)

用 3 个集合来存储被标记为 3 种颜色的对象，程序开始运行时，所有对象都存放在白色标记集合中。

2. 从根节点开始遍历，把遍历到的对象标记为灰色，放到灰色标记集合中，如下图所示：

![Go三色标记法过程3](../image/Go三色标记法过程3.png)

对象 A、对象 E，被标记为灰色。

3. 遍历灰色标记集合，将灰色对象本身标记为黑色，并将它们移动到黑色标记集合中；将黑色对象引用的白色对象标记为灰色，放到灰色标记集合中，如下图所示：

![Go三色标记法过程4](../image/Go三色标记法过程4.png)

对象 A、对象 E，被标记为黑色；对象 B、对象 C、对象 F，被标记为灰色。

4. 重复第三步，直到灰色标记表为空，如下图所示：

![Go三色标记法过程5](../image/Go三色标记法过程5.png)

5. 清除所有的白色对象，完成垃圾回收，如下图所示：

![Go三色标记法过程6](../image/Go三色标记法过程6.png)

明白了三色标记的过程，还需要搞清楚垃圾回收最开始扫描的根集合究竟包含哪些对象，通常情况下根节点包含以下几个部分：

1. 全局变量：程序在编译器就能确定的那些存在于程序整个生命周期的变量；
2. 执行栈上的对象或指针：每个 goroutine 都包含自己的执行栈，这些执行栈上的对象包含栈上的变量及指向分配的堆内存区块的指针；
3. 寄存器中的变量：寄存器的值可能表示一个指针，参与计算的这些指针可能指向某些赋值器分配的堆内存区块。

### 没有 STW 的三色标记法

从上面的分析了解到，STW 会大大的降低用户程序的执行效率，甚至达到用户难以接受的地步。那么 go 经过优化后的并行三色标记法需要 STW 吗？先看一下假设不进行 STW 会不会有什么问题？

以下图的程序对象关系进行分析，假设当前已经完成第一轮扫描，此时灰色对象 F 通过 p 指针指向白色对象 H，如下图所示：

![Go没有STW的三色标记法过程1](../image/Go没有STW的三色标记法过程1.png)

由于没有进行 STW，所有对象都可能发生读写操作。假设还没扫描到对象 F 时，已经标记为黑色的对象 E，创建 q 指针指向白色对象 H，如下图所示：

![Go没有STW的三色标记法过程2](../image/Go没有STW的三色标记法过程2.png)

在新增 q 指针的同时，灰色对象 F 移除 p 指针，此时白色对象 H 只挂在已经完成扫描的黑色对象 E 下，如下图所示：

![Go没有STW的三色标记法过程3](../image/Go没有STW的三色标记法过程3.png)

然后，按照三色标记的规则继续执行，最终会得到如下图所示的结果：

![Go没有STW的三色标记法过程4](../image/Go没有STW的三色标记法过程4.png)

对象 H 其实是被对象 E 正确引用的，但却被垃圾回收器错误地回收了，这将会导致程序严重错误，是不允许的。

从上面的分析来看，在不进行 STW 时，如果同时满足下面两个条件将会破坏垃圾回收器的正确性：

- 一个白色对象被黑色对象引用（白色对象被挂在黑色对象下）
- 灰色对象与他之间的可达关系的白色对象遭到破坏（灰色对象同时丢失了该白色对象的引用）

## 屏障技术

### 强弱三色不变性

根据前面分析垃圾回收器会出现错误回收的两个条件，只要破坏这两个必要条件，就可以保证对象不会被错误回收。也就是两种三色不变形：强三色不变性和弱三色不变性。

- 强三色不变性：不存在黑色对象引用到白色对象的指针，即黑色对象不会指向白色对象，只会指向灰色对象或黑色对象

- 弱三色不变性：所有被黑色对象引用的白色对象都处于灰色对象的保护状态，黑色对象可以指向的白色对象，但是必须包含一条从灰色对象到这个白色对象的可达路径

只要满足了这两种三色不变性其一，就破坏了垃圾回收器的错误回收两个 条件同时存在，就可以保证正确性。go 语言引入内存写屏障技术来实现这两个三色不变性，涉及到 3 种屏障技术：

1. 插入写屏障
2. 删除写屏障
3. 混合写屏障

### 什么是内存屏障

内存屏障其实是一种赋值器技术，对应于在编译期生成的一段特殊代码，用于在程序运行时拦截内存写操作，相当于一个 hook 调用。其作用是通过 hook 内存的写操作时机，做一些标记工作，从而保证垃圾回收的正确性。举个例子：

```go
type Student struct {
	Name string
	Age  *int
}

func func1(s *Student) {
	s.Age = new(int)
}

func func2(s *Student) {
	var st = new(Student)
	st.Name = "google"
}

func main() {
	st1 := new(Student)
	st2 := new(Student)

	go func1(st1)
	go func2(st2)
}
```

对于上述代码，先看一下 他的内存逃逸情况，内存逃逸的原则如下：

1. **尽可能分配到栈上**：在确保程序正确性的前提下，如果可以，将对象分配到栈上。栈上的对象生命周期与 goroutine 紧密相关，当 goroutine 结束时，这些对象会自动释放，避免了垃圾回收的负担，从而提高性能。
2. **堆分配的必要性**：当对象需要在函数调用返回后继续存在，或者对象的大小和结构无法在编译期确定时，就必须将其分配到堆上。这些对象的生命周期由程序的业务逻辑决定，最终由垃圾回收器管理和回收。
3. **不确定性时选择堆分配**：如果无法明确判断对象是否可以分配到栈哈桑，为了保证程序的正确性和稳定性，通常会选择将其分配到堆上。堆上的对象在业务程序的创建时分配，最终由垃圾回收器负责回收。

执行以下命令，查看其内存逃逸情况：

```bash
go build -gcflags "-N -l -m" ./main.go
```

得到输出：

```bash
# command-line-arguments
./main.go:160:12: s does not escape
./main.go:161:13: new(int) escapes to heap
./main.go:164:12: s does not escape
./main.go:165:14: new(Student) does not escape
./main.go:170:12: new(Student) escapes to heap
./main.go:171:12: new(Student) escapes to heap
```

程序当中一共执行了 4 次 new 操作，但只有 3 次逃逸到了堆

```
s.Age = new(int) 逃逸到堆上，因为其生命周期需要超越该 goroutine
var st = new(Student) 分配到栈上，st 对象就只是在栈上使用
st1 := new(Student) 逃逸到堆上，因为其他的 goroutine 要使用该参数
st2 := new(Student) 逃逸到堆上，同上
```

### go 语言中的屏障技术

在 GC 领域中，常见的写屏障（write barrier）有两种：

1. 插入写屏障（Dijistra Insertion Barrier）
2. 删除写屏障（Yuasa Deletion Barrier）

#### 插入写屏障

插入写屏障的原理可以用如下伪代码表示：

```go
// ptr 赋值给 slot
func DijistraWritePointer(slot *unsafe.Pointer, ptr unsafe.Pointer) {
		shade(ptr)	// shade(ptr) 会将新的下游对象 ptr 标记为灰色。通过保守的假设 *slot 可能会变为黑色，并确保 ptr 不会在将赋值为 *slot 前变为白色，进而确保了强三色不变性。
		*slot = ptr // 将新的下游对象 ptr 赋值给当前下游对象 slot。
}
```

上述伪代码可以翻译如下：

```go
添加下游对象(当前下游对象 slot，新下游对象 ptr) {
		// step 1
		将新的下游对象 ptr 标记为灰色
		
		// step 2
		当前下游对象 slot = 新下游对象 ptr
}
```

插入写屏障一般有两种适用场景：

- A 添加新下游对象，比如 A 之前没有下游，新添加一个下游对象 B，B 被标记为灰色；
- A 变更下游对象，比如 A 将下游对象 C 更换为 B，B 被标记为灰色。

由于指针修改时，指向的新对象要被强制标灰，所以插入写屏障满足强三色不变性，不存在黑色对象引用白色对象的情况了，因为白色会强制变成灰色。

> 注意：虽然插入写屏障实现非常的简单，并且也能保证强三色不变性，但却没有在栈上使用，因为栈空间的特点是容量小，但要求响应速度快，在栈上的对象增加写屏障，会大幅度增加写入指针的额外开销，所以在栈空间的对象操作中不使用，仅仅是用在堆空间的对象操作中。

下面用图示的方式展示插入写屏障的过程，假设应用程序中的对象关系如下图所示：

1. 程序初始阶段，所有对象均标记为白色，将所有对象放入到白色集合

![Go插入写屏障过程1](../image/Go插入写屏障过程1.png)

注意：对象 E 的箭头是由堆指过来，并不是表示是从堆上开始扫描，其实也是从栈上扫描的，只不过是栈上根节点直接引用的它，它位于堆上，这里方便就用堆上的箭头指向它。

2. 从根节点开始遍历，把遍历到的对象标记为灰色（只遍历一次），放到灰色标记集合中，如下图所示：

![Go插入写屏障过程2](../image/Go插入写屏障过程2.png)

3. 遍历灰色集合，将可达对象从白色标记为灰色，放入灰色集合，并将自身标记为黑色放入黑色集合中

![Go插入写屏障过程3](../image/Go插入写屏障过程3.png)

4. 由于是并发进行标记，此时对象 E 指向一个新的对象 H，对象 A 指向一个新的对象 I，对象 E 在堆区，触发插入写屏障，对象 A 在栈区，不触发

![Go插入写屏障过程4](../image/Go插入写屏障过程4.png)

5. 插入写屏障的作用（黑色对象添加白色对象，将白色对象标记为灰色），对象 H 被标记为灰色，由于栈上没有开启写屏障，所以对象 I 仍然为白色

![Go插入写屏障过程5](../image/Go插入写屏障过程5.png)

6. 循环执行上述流程，直到灰色集合没有节点

![Go插入写屏障过程6](../image/Go插入写屏障过程6.png)

可以看到出现了黑色对象 A 指向白色对象 I 的情况，会出现回收错误，这是由于在栈上没有开启写屏障导致的，所以在全部三色标记扫描之后，要对栈重新进行三色标记扫描，但这次为了对象不丢失，要对本次扫描启动 STW，直到栈空间的三色标记结束

7. 在正式开始回收工作之前，此时开启 STW，开始重新扫描一次栈上对象

![Go插入写屏障过程7](../image/Go插入写屏障过程7.png)

8. 对栈上的对象进行三色标记，直至没有灰色对象

![Go插入写屏障过程8](../image/Go插入写屏障过程8.png)

9. 停止 STW，这次 STW 大约的时间在 10~100 ms 之间

![Go插入写屏障过程9](../image/Go插入写屏障过程9.png)

10. 将剩余的白色节点全部清除

![Go插入写屏障过程10](../image/Go插入写屏障过程10.png)

#### 删除写屏障

删除写屏障的原理可以用如下伪代码表示：

```go
func YuasaWB(slot *unsafe.Pointer, ptr unsafe.Pointer) {
		shade(*slot)	// 将 *slot 标记为灰色，即指针修改时，修改前指向的对象要标灰
		*slot = ptr		// 将新的下游对象 ptr 赋值给当前下游对象 slot
}
```

上述伪代码可以翻译如下：

```
添加下游对象(当前下游对象 slot，新下游对象 ptr) {
		// step 1
		if (当前下游对象 slot 是灰色 || 当前下游对象 slot 是白色) {
				标记灰色（当前下游对象 slot）	// slot 为当前下游对象，即将被删除，标记为灰色
		}
		
		// step 2
		当前下游对象 slot = 新下游对象 ptr
}
```

删除写屏障一般有两种适用场景：

- A 删除下游对象，比如 A 之前的下游对象 B 被删除，B 被标记为灰色；
- A 变更下游对象，比如 A 将下游对象 C 更换为 B，C 被标记为灰色；

由于指针修改时，修改前指向的对象要标灰，即被删除的对象，如果自身为灰色或者白色，那么被标记为灰色；所以满足弱三色不变性，因为保护灰色对象到白色对象的路径不会断。

注意，虽然删除写屏障也是 GC 领域常见的屏障技术，但是 go 语言在 GC 中从来没有直接使用删除写屏障。

假设应用程序中的对象关系如下图所示，下面用图示的方式展示删除写屏障的过程：

1. 程序初始阶段，所有对象均标记为白色，将所有对象放入到白色集合

![Go删除写屏障过程1](../image/Go删除写屏障过程1.png)

2. 从根节点开始按照三色标记遍历，标记到如下图所示的状态：

![Go删除写屏障过程2](../image/Go删除写屏障过程2.png)

3. 此时用户程序将原本对象 E 指向对象 F 的指针指向对象 G，即对象 E 删除对象 F，添加对象 G；触发删除写屏障，由于对象 F 已经被标记为灰色，所以不做改变，如下图所示：

![Go删除写屏障过程3](../image/Go删除写屏障过程3.png)

4. 用户程序将对象 F 指向对象 G 的指针删除，触发删除写屏障，对象 G 被标记为灰色，如下图所示：

![Go删除写屏障过程4](../image/Go删除写屏障过程4.png)

5. 按照三色标记法和删除写屏障的步骤继续往下执行，最终得到的结果如下图所示：

![Go删除写屏障过程5](../image/Go删除写屏障过程5.png)

可以看到由于有删除写屏障的存在，可以准确回收掉不需要的内存，不会出现错误回收的情况，但是却会出现回收精度低的问题，同时注意上方，对象 F 其实是一个被孤立的对象，不会再使用了，却最终被标记为黑色，没有被回收掉，只能通过下一轮 GC 回收，所以，删除写屏障虽然不需要在标记结束后开启 STW，但却存在回收精度低的问题。

##### 删除写屏障是否真的不需要 STW

前面分析，删除写屏障虽然不需要在标记结束后开启 STW，是否意味着单独使用删除写屏障进行 GC 就不需要 STW 了呢？

其实并非如此，删除写屏障又叫基于起始快照的解决方案（snapshot-at-the-begining）。删除写屏障在使用的时候有一个前提条件，就是必须起始的时候，把整个根部扫描一遍，做一次快照，让所有的可达对象全都在灰色保护下（根对象全为黑，下一级在堆上的对象全灰），之后利用删除写屏障拦截内存写操作，确保弱三色不变性不被破坏，这样就绝对不会有被误收回的对象，就可以保证垃圾回收的正确性。而在起始阶段，扫描整个根节点，做快照的时候是要进行 STW 的，所以从整体看删除写屏障同样要进行 STW。

下面通过一个简单的图示看一下，经过了 STW 快照之后的删除写屏障过程：

![Go删除写屏障STW过程1](../image/Go删除写屏障STW过程1.png)

1. 起始阶段，根节点全黑，堆上一级节点全灰
2. 开始三色标记
3. 新增黑色对象 A 指向白色对象 C
4. 对象 B 删除对象 C，触发删除写屏障，对象 C 置灰，避免黑色对象引用白色对象

总结：

1. 删除写屏障必须在起始阶段，开启 STW 来扫描整个栈（注意所有的 goroutine 栈，所以整个用户程序所有的 goroutine 都要扫描，所以是 STW，STW 是让用户所有的 goroutine 全部停止），来确保堆上的一级对象全灰，保证所有堆上在用的对象都处于灰色保护下，才能保证弱三色不变性。
2. 删除写屏障需要在起始阶段开启 STW 扫描，因此不适合具有大栈内存的场景，栈越大，扫描时间越久，比如现代服务器程序栈内存都相对较大，所以都不太适合删除写屏障。相反，它更适合栈内存较小的环境，如嵌入式系统和物联网设备，因为它们的栈空间有限，STW 时间较短。
3. 删除写屏障的可能会有遗漏对象需要在下一轮 GC 才可能被回收，所以税收京都相对较低，不如插入写屏障。

思考题：前面分析在使用删除写屏障之前需要 STW 来扫描整个栈空间获取快照，那是否可以不一次性暂停所有的 goroutine，而是一个栈一个栈的暂停获取快照？这样就不需要 STW 了。

举个例子：

1. 对象 A 是 goroutine1 里栈上的一个对象，goroutine1 里的栈空间已经扫描完了，并且对象 C 也扫描完标记为黑色的对象；
2. 对象 B 是 goroutine2 里栈上的对象，指向了 goroutine1 里的对象 C 和 goroutine2 里的对象 D，由于 goroutine2 还没有完全扫描，对象 B 是一个灰色对象，对象 D 是白色对象。

![Go删除写屏障STW过程2](../image/Go删除写屏障STW过程2.png)

此时假设执行以下步骤：

第一步：goroutine2 进行赋值变更，把对象 C 指向 D 对象，此时黑色对象 C 就指向了白色的 D（这里是删除屏障，而不是插入写屏障，所以新增引用不会触发任何操作）

第二步：删除对象 B 到对象 D 的引用，由于是栈对象操作，不会触发删除写屏障。

执行完上述两个，结果如下图：

![Go删除写屏障STW过程3](../image/Go删除写屏障STW过程3.png)

由于对象 C 已经是黑色对象了，所以不会再扫描，所以对象 D 就会被错误的清理掉。

所以，一个栈一个栈的暂停获取快照是不可行的，必须 STW，暂停用户程序的所有 goroutine 的栈空间，来打快照，把所有的堆对象都处于灰色保护中才行。

#### 混合写屏障

思考下删除写屏障的弊端和流程，发现它最大的问题就是起始阶段的栈空间扫描，要进行 STW 暂停整个的用户程序，而一个一个的栈暂停又会出现问题，那有没有什么办法可以解决这个问题呢？

回顾上面删除写屏障的例子的第一步，在把对象 C 指向对象 D 的时候，正是由于此时是删除写屏障，所以导致黑色对象 C 就指向了白色的对象 D 而没有任何操作，那如果在这里加入插入写屏障的逻辑，此时对象 D 就会被置灰，尽管后面对象 C 已经是黑色不会再被扫描，也不会出现黑色对象指向白色对象的情况了。这里引入的插入写屏障还是在一个一个的栈暂停的情况下的，是不需要进行 STW 的。这里既用到了删除写屏障，又用到了插入写屏障，这就是混合写屏障。

混合写屏障模式下，利用删除写屏障避免了插入写屏障的 STW 问题（全部三色标记扫描之后，要 STW 对栈重新进行三色标记扫描），又利用插入写屏障避免了删除写屏障的 STW 问题（使用删除写屏障之前需要 STW 垃圾扫描整个栈空间，获取快照，把所有的堆对象都处于灰色保护中），这样就解决了屏障技术带来的 STW 问题。

Go 在 Go v1.8 版本时候为了简化 GC 的流程，同时减少标记终止阶段的重扫成本，将 Dijkstra 插入屏障和 Yuasa 删除屏障进行混合，引入了混合写屏障机制（hybrid write barrier）。

混合写屏障的基本思想是：对正在被覆盖的对象进行着色，且如果当前栈未扫描完成，则同样对指针进行着色。

混合写屏障的原理可以用如下的伪代码表示：

```go
func HybridWritePointerSimple(slot *unsafe.Pointer, ptr unsafe.Pointer) {
		shade(*slot)
		shade(ptr)
		*slot = ptr
}
```

可以做如下翻译

```
添加下游对象(当前下游对象 slot, 新下游对象 ptr) {
		// step1
		标记灰色(当前下游对象 slot)	// 只要当前下游对象被移走，就标记灰色
    
		// step2
		标记灰色(新下游对象 ptr)	// 新下游对象标记为灰色
		
		// step3
		当前下游对象 slot = 新下游对象 ptr
}
```

意思是在垃圾回收阶段，只要堆上的一个赋值`*slot = ptr`那么都会被拦截住，然后把旧值（`*slot`）指向的对象，和新值（`ptr`）指向的对象都置灰（投到扫描队列）。

所以混合写屏障的流程可以总结为：

- GC 开始将站上的对象全部扫描并标记为黑色（注意是一个一个栈标记，不是所有栈全部暂停标记）
- GC 期间，任何在栈上创建的新对象，均标记为黑色
- 被删除的堆对象标记为灰色
- 被添加的堆对象标记为灰色

假设应用程序中的对象关系如下图所示，下面用图示的方式展示混合写屏障的过程：

![Go混合写屏障过程1](../image/Go混合写屏障过程1.png)

1. GC 开始扫描栈对象，将所有栈上可达对象 A、B、C 标记为黑色

![Go混合写屏障过程2](../image/Go混合写屏障过程2.png)

2. GC 期间栈上新创建的对象 K 被标记为黑色

![Go混合写屏障过程3](../image/Go混合写屏障过程3.png)

3. 进行三色标记到如下阶段，对象 E 被标记为黑色，对象 F 被标记为灰色

![Go混合写屏障过程4](../image/Go混合写屏障过程4.png)

4. 此时，对象 E 新增指针指向对象 I，对象 F 删除对对象 H 的指针引用，触发混合写屏障，对象 I 标记为灰色，对象 H 标记为灰色

![Go混合写屏障过程5](../image/Go混合写屏障过程5.png)

5. 按照三色标记法和混合写屏障的步骤继续向下执行，最终得到的结果如下图所示：

![Go混合写屏障过程6](../image/Go混合写屏障过程6.png)

最终垃圾对象为白色对象 D、G，将会被垃圾回收器清理掉。

总结：

1. 混合写屏障结合了插入和删除写屏障的优势。它不需要在开始时进行全局的 STW 操作来创建快照，也不需要在三色标记扫描之后，进行 STW 对栈重新进行三色标记扫描。
2. 混合写屏障保留了删除写屏障的功能，所以其扫描精度比插入写屏障低，但它实现了整个 GC 过程中无 STW。
3. 虽然混合写屏障整个 GC 过程中无 STW，然而在扫描某个特定的栈时，还是需要暂时停止该 goroutine 的赋值器操作，以确保状态的原子切换。

## GC 的完整流程

Go 语言 GC 相关的代码在`runtime/mgc.go`文件中，一共分为`清除终止(SweepTermination)`，`标记(Mark)`，`标记终止(MarkTermination)`和`清除(Sweep)`四个不同阶段，它们分别完成了不同的工作：

1. 清除终止（SweepTermination）

这个阶段的主要任务是结束上一个 GC 周期的清除工作，并为新的 GC 周期做准备。

- 会进行 STW，所有处理器 P 在这时会进入安全点（Safe Point）
- 会启动后台 MarkWork 协程

2. 标记（Mark）

- 将 GC 状态从`_GCoff`更改为`_GCmark`，并且开启写屏障（Write Barrier）和协助线程（mutator assists），紧接着将根对象入队
- 恢复用户程序的正常执行，标记进程（mark workers）和协助线程（mutator assists）开始自发地标记内存中的对象，写屏障会将被覆盖的指针和新指针都标记成灰色，而所有新创建的对象都会直接标记成黑色
- 遍历灰色对象集合，将灰色对象标记为黑色，并将该对象指向的对象标记为灰色
- 使用分布式终止算法来检测剩余工作，即何时不再有根标记作业或灰色对象，如果没有了则转为标记终止（MarkTermination）阶段

3. 标记终止（MarkTermination）

- 执行 STW
- 将 GC 状态切换至`_GCmarktermination`，关闭 GC 工作线程以及协助线程（mutator assists）
- 清理处理器 P 上的缓存（mcache）

4. 清除（Sweep）

- 将 GC 状态切换至`_GCoff`，初始化清理状态并关闭写屏障（Write Barrier）
- 恢复用户程序的正常执行，从此时开始所有新创建的对象会标记成白色
- 后台并发清理所有的内存管理单元，当应用程序 goroutine 尝试在堆内存中分配新内存时，会触发该操作

## GC 的触发时机

Go 语言中 GC 的触发分为手动触发和被动触发两种

1. 手动触发，通过调用`runtime.GC()`来触发 GC，此调用阻塞式地等待当前 GC 运行完毕
2. 被动触发，分为两种方式：
	- go 后台有一系统监控线程，当超过两分钟没有产生任何 GC 时，强制触发 GC
	- 使用步调算法，通过内存增长的比例来触发 GC，每次内存分配时检查当前内存分配量是否已达到阈值（环境变量 GOGC）：默认 100%，即当内存扩大一倍时启用 GC
		- 可以通过`debug.SetGCPercent(500)`来修改步调，这里表示，如果当前堆大小超过了上次标记的堆大小的 500%，就会触发
		- 而第一次 GC 的触发的堆内存临界值是 4 MB

总结：

1. 监控线程`runtime.sysmon`定时调用
2. 手动调用`runtime.GC`函数进行垃圾手机
3. 申请内存时`runtime.mallocgc`会根据堆大小判断是否调用

## 小结

Go 语言 GC 总体上来说是采用的并行三色标记法 + 混合写屏障机制来实现的，内存写屏障是由插入写屏障向混合写屏障过渡的，Go 语言在 Go V1.7 之前其实就使用的是插入写屏障（Dijkstra Write Barrier），在 Go V1.8 版本引入了混合写屏障。

1. 插入写屏障没有完全保证完整的强三色不变式，由于性能影响，栈上对象没有开启写屏障，所以三色标记完成之后，最后必须 STW 重新扫描栈。
2. 混合写屏障消除了屏障过程中所有的 STW，不用 STW 扫描栈，但由于引入了删除写屏障，所以损失了一定的回收精度，其回收精度和删除写屏障的一致，比插入写屏障要低。
3. 混合写屏障扫描栈的方式是逐个暂停扫描的，不需要 STW。