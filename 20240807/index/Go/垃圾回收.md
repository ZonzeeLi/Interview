# 垃圾回收

## 常见的 GC 算法

### 引用计数法

引用计数法会为程序中的每个对象在对象头中分配一个空间来保存该对象被引用的次数，如果有其他对象引用了该对象，那么它的引用计数加 1。如果其他对象删除了对该对象的引用，则它的引用计数减 1，当该对象的引用计数为 0 时，此时没用任何引用，就可以被回收。

#### 优点

简单直接，回收速度快，不会出现内存耗尽或达到某个阈值时才回收。

#### 缺点

不能很好的处理循环引用，而且需要有额外的空间实时维护引用计数，也有一定的代价

![Go引用计数法缺点](../image/Go引用计数法缺点.png)

比如上图，在删除了对象 A 和 D 之后，由于对象 B 和 E 之间存在循环引用，所以上下 B、C、E、F 四个对象都存在引用关系，计数都不为 0，所以不能被回收，如果大量存在这种循环对象，就会造成一定的内存泄漏。

### 标记清除法

标记清除算法主要分为两个阶段：

标记阶段：遍历所有活动对象，并标记那些还在使用的对象标签。

清除阶段：遍历内存中所有对象，清除那些没有被标记的对象。

![Go标记清除法](../image/Go标记清除法.png)

#### 优点

简单易实现，不需要额外的数据接口，只需遍历一次对象图即可完成标记和清除操作，适合可回收对象不多的场景。

#### 缺点

主要是会造成内存碎片，导致后续需要创建大对象的时候，由于没有连续的足够大的内存空间而创建不了，降低了内存的使用率。

### 复制法

复制算法将内存分成两个相等的区域，并且一次只使用其中一个。当这个区域被用完时，程序会把所有还在使用的对象复制到另一个空区域（保留区域），然后将已使用的区域全部清除。这样，每次只需对一个区域进行垃圾回收，分配内存时也无需处理碎片问题，只需按顺序移动指针进行分配。

![Go复制法1](../image/Go复制法1.png)

![Go复制法2](../image/Go复制法2.png)

#### 优点

主要是避免了内存碎片问题，每次清除针对的都是整块内存。

#### 缺点

内存利用率低，使用的内存会缩小为原来的一半。如果存活的对象很多，将这些对象都复制一遍，并且更新它们的应用地址，这一过程耗时可能较长，回收效率不够高。

### 分代法

分代收集算法可以被视为上述内容的扩展。它的实现思路是根据对象生命周期的差异，将内存划分为多个区域，例如将堆空间划分为新生代和老年代，然后根据每个区域的特点选择最合适的收集算法。

在新生代中，由于存在大量对象很快被销毁、少量对象存活的特点，通常使用“复制算法”。这种算法只需付出少量存活对象的复制成本就可以完成垃圾对象的收集，效率非常高。而在老年代中，由于对象的存活率高，且没有额外空间进行分配担保，通常使用“标记-清理”或“标记-整理”算法来进行回收。

## Go 语言 GC 算法

### 为什么 go 语言 gc 不选择分代与标记整理

1. go 为什么没有选用标记整理或者复制？

标记整理算法或者复制算法主要是为了减少内存碎片，然而，Go 运行时使用的内存分配算法是基于 tcmalloc，虽然不能像复制算法那样消除掉内存碎片化的问题，但也极大地降低了碎片率，所以标记整理显得有时并不是那么明显，并且 Thread Cache 的分配机制使得 Go 在大多数分配场景下可以避免使用锁，从而在高并发情况下展现出强大的性能优势。

2. go 为什么没有选择分代？

go 语言的 struct 类型创建是可以分配到栈上的，而不是像 java 一样 new 出来的对象在堆上。go 会在编译期做静态逃逸分析，可以将生命周期很短的对象直接安排在栈上分配（比如函数内未发生的逃逸的 struct 类型变量），分代 GC 最大的优势就是可以区分长生命周期和短生命周期对象，从而快速回收生命周期短的对象，但是由于 go 语言在编译期会做逃逸分析，所以 go 语言中的短生命周期对象并没有那么多，使得分代 GC 在 go 语言中受益并不明显。此外，分代 GC 还需要额外的写屏障来维护老年代对新年代的引用关系，这也增加了 GC 的开销。


