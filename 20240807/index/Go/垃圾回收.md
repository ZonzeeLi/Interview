# 垃圾回收

## 常见的 GC 算法

### 引用计数法

引用计数法会为程序中的每个对象在对象头中分配一个空间来保存该对象被引用的次数，如果有其他对象引用了该对象，那么它的引用计数加 1。如果其他对象删除了对该对象的引用，则它的引用计数减 1，当该对象的引用计数为 0 时，此时没用任何引用，就可以被回收。

#### 优点

简单直接，回收速度快，不会出现内存耗尽或达到某个阈值时才回收。

#### 缺点

不能很好的处理循环引用，而且需要有额外的空间实时维护引用计数，也有一定的代价

![Go引用计数法缺点](../image/Go引用计数法缺点.png)

比如上图，在删除了对象 A 和 D 之后，由于对象 B 和 E 之间存在循环引用，所以上下 B、C、E、F 四个对象都存在引用关系，计数都不为 0，所以不能被回收，如果大量存在这种循环对象，就会造成一定的内存泄漏。

### 标记清除法

标记清除算法主要分为两个阶段：

标记阶段：遍历所有活动对象，并标记那些还在使用的对象标签。

清除阶段：遍历内存中所有对象，清除那些没有被标记的对象。

![Go标记清除法](../image/Go标记清除法.png)

#### 优点

简单易实现，不需要额外的数据接口，只需遍历一次对象图即可完成标记和清除操作，适合可回收对象不多的场景。

#### 缺点

主要是会造成内存碎片，导致后续需要创建大对象的时候，由于没有连续的足够大的内存空间而创建不了，降低了内存的使用率。

### 复制法

复制算法将内存分成两个相等的区域，并且一次只使用其中一个。当这个区域被用完时，程序会把所有还在使用的对象复制到另一个空区域（保留区域），然后将已使用的区域全部清除。这样，每次只需对一个区域进行垃圾回收，分配内存时也无需处理碎片问题，只需按顺序移动指针进行分配。

![Go复制法1](../image/Go复制法1.png)

![Go复制法2](../image/Go复制法2.png)

#### 优点

主要是避免了内存碎片问题，每次清除针对的都是整块内存。

#### 缺点

内存利用率低，使用的内存会缩小为原来的一半。如果存活的对象很多，将这些对象都复制一遍，并且更新它们的应用地址，这一过程耗时可能较长，回收效率不够高。

### 分代法

分代收集算法可以被视为上述内容的扩展。它的实现思路是根据对象生命周期的差异，将内存划分为多个区域，例如将堆空间划分为新生代和老年代，然后根据每个区域的特点选择最合适的收集算法。

在新生代中，由于存在大量对象很快被销毁、少量对象存活的特点，通常使用“复制算法”。这种算法只需付出少量存活对象的复制成本就可以完成垃圾对象的收集，效率非常高。而在老年代中，由于对象的存活率高，且没有额外空间进行分配担保，通常使用“标记-清理”或“标记-整理”算法来进行回收。

## Go 语言 GC 算法

