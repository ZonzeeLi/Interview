# 内存逃逸

## 什么是逃逸

函数的运行都是在栈上运行的，在栈上声明临时变量，分配内存，函数运行完毕之后，回收内存，每个函数的栈空间是独立的，其他函数是无法进行访问，但是在某些情况下栈上面的数据需要在函数结束后还能被访问，这时候就会内存逃逸。

如果变量从栈上面逃逸，会跑到堆上面，栈上面的变量在函数结束的时候自动回收，回收代价比较小，栈的内存分配和使用一般只需要两个 CPU 指令`PUSH`和`RELESE`，分配和释放，而堆分配内存，频繁的使用垃圾回收，则会占用比较大的系统开销，所以尽量分配内存到栈上面，减少 GC 的压力，提高运行速度。

## 逃逸分析过程

Go 语言最基本的逃逸分析原则：如果一个函数返回一个对变量的引用，那么它就会发生逃逸。

在任何情况下，如果一个值被分配到了栈之外的地方，那么一定是到了堆上面。简而概之：编译器会分析代码的特征和代码生命周期，Go 中的变量只有在编译器可以证明在函数返回后不会再被引用的，才会被分配到栈上，否则分配到堆上。

Go 语言里面没有一个关键字或者函数可以直接让变量被编译器分配到堆上，相反，编译器是通过分析代码来决定将变量分配到何处。如果函数外部没有引用，则优先放到栈中，如果函数外部存在引用，则必定放到堆中。

## 指针逃逸

传递指针可以减少底层值的拷贝，可以提高效率，但是如果拷贝的数据量小，由于指针传递会产生逃逸，可能会使用堆，也可能会增加 GC 的负担，所以传递指针不一定是高效的。比如如下代码：

