# Redis专项题库

## 对象

### Set 一个已有的数据会发生什么？

覆盖原先的数据。

### 浮点型在String是用什么表示？

用字符串表示。

### String可以有多大？

最大是 512 MB，不过可以通过配置文件进行修改。

### Redis字符串是怎么实现的？

底层数据结构是 SDS 简单字符串。SDS 记录了 len 长度， 可以在 O(1) 的时间复杂度内计算长度，二进制安全，避免了缓冲区溢出，减少修改字符串长度的内存重新分配次数。

补充：Redis 字符串底层是 String 对象，有三种编码方式：int 型、embstr 型、raw 型。如果是存一个整形，可以用 long 表示的整数就用 int 编码存储；如果是存一个字符串，当字符串小于一个阈值，就用 embstr 编码；大于阈值，则用 raw 编码。在3.2 版本之后阈值是 44.

### 为什么EMBSTR的阈值是44？

Redis 使用 jemalloc 分配内存，jemalloc 按照 64 字节分界，所以 Redis 如果字符串对象超过 64 字节用 raw，否则使用 embstr 对象，其中，Redis 对象是有 redisobject 和 sds 两部分组成，redisobject 占用 16 字节，sds 中有记录 len 长度、记录申请内存空间、标识位，占用 3个字节，还有个 '\0' 是保留 C 字符串的结尾标志符，所以阈值是 64 - 16 - 3 -1 = 44.

### 你知道为什么EMBSTR曾经的阈值是39吗？

之前的 SDS 结构没有做分类，现在的 SDS 分为了 8 字节、16 字节、32 字节、64 字节。减少了 6 字节的空间，但是多了一个标识位，所以曾经的阈值是 44 - 6 + 1 = 39.

补充：3.2 版本之后，对 SDS 结果进行了拆分，EMBSTR 用的是 sdshdr8，总容量和已使用容量字段减少了 6 个字节，但增加了一个 flag 字段，所以最终节约了 5 个字节。

### SDS有什么用？c

1. SDS 记录了 len 长度，可以以 O(1) 的时间复杂度计算长度；
2. 二进制安全，不以 '\0' 作为字符串结尾的判断；
3. 提前预留空间，减少修改字符串长度的内存重新分配次数。

### List是完全先入先出吗？

不一定，List 有 LPOP、LPUSH、RPOP、RPUSH 的操作，不一定完全按照先入先出的操作，根据指令执行，也可能后入先出。

### List对象底层编码方式是什么？

3.2 版本之前是使用 ziplist 和 linkedlist，如果所有字符串对象长度小于 64 字节，且 list 长度小于 512，则使用 ziplist，否则使用 linkedlist。

3.2 版本之后使用的是 quicklist，quicklist 其实就是将 ziplist 以 linkedlist 的方式连起来，结合了二者的优点。

后续版本中由于 ziplist 的连锁更新问题，将 ziplist 替换成了 listpack。

### ZIPLIST是怎么压缩数据的？

ziplist，包含三部分，头部分、数据部分、结尾部分。头部分主要分为记录节点的个数、结尾地址偏移量、字节数。数据部分，每一个数据都记录了，prelen上一个数据的长度、编码类型、内容。结尾部分是一个标识。

补充：结构头记录了字节数、起始地址居尾部距离、节点个数。

### ZIPLIST下List可以从后往前遍历吗？

可以。由于 ziplist 中的数据部分中每个节点记录了上一个节点的长度，所以可以计算出上一个节点的位置。

### 在ZIPLIST数据结构下，查询节点个数的时间复杂度是多少？

O(1)。由于在 ziplist 的头部分记录了节点个数，所以可以直接查询，但如果节点个数超过65535，那么只能通过遍历查询，时间复杂度是 O(n)。

### LINKEDLIST编码下，查询节点个数的时间复杂度是多少？

O(1)。由于在 linkedlist 头结构中记录了节点个数，所以可以直接查询。

### Set编码方式？

Set 的底层实现，如果 Set 的值都是整数且数量小于 512，会使用 Intset，否则使用哈希表。

### Set是有序的吗？

如果使用intset 是有序的，哈希则无序。

### HSet的编码方式是什么？

HSet 的底层实现，如果 HSet 的值小于 64 字节且数量小于 512，会使用 ziplist，否则使用哈希表。

### HSet查找某个key的平均时间复杂度是多少？

如果是 ziplist 是 O(n)，如果是哈希表是 O(1)。

### Redis中HashTable查找元素总数的平均时间复杂度是多少?

O(1)。由于在哈希表头结构中记录了节点个数，所以可以直接查询。

补充：hashtable的表头结构中有储存键值对数量的字段。

### HSet（字典）为什么要用两种编码方式？

元素长度小且数量少采用ziplist，可以节约内存，如果元素数量大，则使用哈希表，可以更快的查找。

### 一个数据在HashTable中的存储位置，是怎么计算的？

通过哈希函数计算 key 的哈希值，然后与哈希掩码做与运算得到索引值，索引值就是这个数据在 hashtable 中的存储位置。

### HashTable怎么扩容？

哈希表的底层结构其实有两张表，扩容会生成新哈希表 ht[1] 并为之分配空间，新表的大小为第一个大于等于原表2倍长度的2次方幂，比如原表used = 500，2倍就是 1000，那么第一个大于 1000 的 2 次方幂是 1024，将字典的偏移索引rehashidx从 -1 设置为 0，Rehash开始，将 ht[0] 的数据 迁移到 ht[1]，Rehash 期间，每次对字典的增删改查操作，会顺带迁移一个 ht[0] 的数据，并更新偏移索引。最终在某个时间点，ht[0] 的所以键值会被 Rehash 至 ht[1]，然后更换 ht[1] 和 ht[0] 的指针，并将 rehashidx 设为 -1.

### HashTable怎么缩容？

哈希表的底层结构其实有两张表，扩容会生成新哈希表 ht[1] 并为之分配空间，新表的大小为第一个大于等于原表2倍长度的2次方幂，比如原表used = 500，2倍就是 1000，那么第一个大于 1000 的 2 次方幂是 1024，将字典的偏移索引rehashidx从 -1 设置为 0，Rehash开始，将 ht[0] 的数据 迁移到 ht[1]，Rehash 期间，每次对字典的增删改查操作，会顺带迁移一个 ht[0] 的数据，并更新偏移索引。最终在某个时间点，ht[0] 的所以键值会被 Rehash 至 ht[1]，然后更换 ht[1] 和 ht[0] 的指针，并将 rehashidx 设为 -1.

### 什么时候扩容，什么时候缩容

Redis 的负载因子是使用空间和总空间大小的比例，当负载因子大于等于1，如果没有执行 bgsave 或 bgrewrireof 这两个复制命令，会发生扩容。如果负载因子大于等于5，即使执行了复制命令，也会发生扩容。当负载因子小于 0.1 后，进行缩容。

### ZSet底层有几种编码方式？

ZSet 的底层实现，如果每个元素长度都小于 64 字节且数量小于 128 个则使用 ziplist ，否则使用 skiplist + 哈希表。

### 跳表编码模式下，查询节点总数的平均时间复杂度是多少？

O(1)。由于跳表的表头结构中记录了节点个数，所以可以直接查询。

### 跳表插入一条数据的平均时间复杂度是多少

跳表是一种支持多级索引的结构，查询效率可以媲美二分查找，插入一条数据也是先查找再索引重建，平均时间复杂度是 O(logN)。

### 为什么跳表和 HashTable 要配合使用

当 ZSet 要根据成员来查找分值，使用哈希表来实现，时间复杂度是 O(1)。当进行范围操作，使用有序的跳跃表来实现。

### 跳表中一个节点的层高是怎么决定的？

跳表的层高是通过概率计算出来，每次计算都有 0.25 的概率使层高 +1，最大高度为 32。

## Redis执行

### Redis是单线程还是多线程

Redis 的单线程是指处理命令并执行的过程是单线程处理，但是 Redis 并不是单线程，Redis 启动后会启动后台线程，用来处理关闭文件、AOF 日志刷盘、lazyfree 释放内存。Redis 6.0 之前对于网络 I/O 的处理是多路复用，而 6.0 之后 又引入了多线程用来处理网络 I/O，为了解决网络的瓶颈。

### Redis为什么选择单线程做核心处理

1. 单线程处理可以避免多线程的并发问题和线程切换的资源浪费，减少锁的使用。
2. CPU 并不是制约 Redis 处理速度的问题，更多是因为网络限制和内存大小。

### 为什么单线程还能这么快

1. 单线程处理可以避免多线程的并发问题和线程切换的资源浪费，减少锁的使用。
2. Redis 采用了高效的数据结构，在内存中处理。
3. Redis 使用 I/O 多路复用来处理网络瓶颈，可以同时监听多个 socket。

### Redis6.0之后引入了多线程，你知道为什么吗？

为了更好的解决网络限制的问题，引入多线程来处理网络请求。

补充：Redis 的主要瓶颈是 I/O 不是 CPU，在部分高并发场景，单核 CPU 处理不过来，针对核心处理流程的解包、发包采用了多线程优化。

### Redis6.0的多线程是默认开启的吗？

不是，需要在配置文件中开启。

### Redis6.0的多线程主要负责命令执行的哪一块

主要负责的是写事件，如果负责读时间需要在配置文件中开启。

补充：原来核心流程中的 I/O 处理，包括解包和回包，也就是读写客户端 socket 的 I/O，这两部分都消耗 CPU 的时间，多线程的引入就是为了解决单核 CPU 在高并发的情况下不够用的情况。

## Redis持久化

### RDB和AOF本质区别是什么？

- RDB 是快照文件，AOF 是日志文件；
- 故障恢复，RDB 会丢失较多数据，AOF 只会丢失少量数据；
- RDB 写入的速度快，AOF 由于命令较多，可能导致文件过大，写入速度较慢。

补充：操作的开销：每一次 RDB 都是全量保存，AOF 是追加操作。

### 如果RDB和AOF只能选一种，你选哪个？

如果为了更高的数据安全性，选择 AOF；如果为了更高的性能，选择 RDB。只选一个选 RDB，因为 Redis 默认也是开启 RDB，不开启 AOF。

### RDB触发条件是什么？触发时机又是什么？

RDB 会在执行 save 或者 bgsave 命令时进行触发，并且会在 Redis 关闭前执行一次 RDB。

补充：主要是调用 save 或者 bgsave 命令、根据配置周期进行、在关闭之前，这三个比较常见，其他的还有主从全量复制发送 RDB 文件、客户端执行数据库清空命令FlushAll。

### AOF触发条件是什么？触发时机又是什么？

Redis 执行完命令会将命令写入到缓冲区，然后调用 write() 写入到 AOF 文件，但是并没有刷盘，AOF 有三种写回策略，一种是 always，会在每次执行完写命令后刷盘；一种是 everysec，每隔一秒执行一次；一种是 No，由操作系统决定刷盘时机。

补充：AOF 的触发流程主要有 3 个，Redis 关闭的时候、每一次事件循环钩子函数 beforeSleep()、每一次事件循环函数 servercron 里面。

### RDB对主流程有什么影响？

save 命令由主进程执行快照，如果快照过大会阻塞主进程；bgsave 命令由子进程执行，如果数据量过大，fork 的过程会阻塞主进程，且在大量写时复制时，会消耗过多内存。

### AOF对主流程有什么影响？

如果是 always 策略，会在大量操作的时候阻塞主进程；如果是 everysec，如果后台线程没有处理完成，那么会阻塞主线程；AOF 重写过程中，如果数据量过大，fork 子进程会阻塞主进程。

补充：如果是everysec策略，如果后台线程上一轮的fsync没有完成，会导致本轮主线程执行write被阻塞，直到fsync完成。

### AOF混合持久化方案是什么？

在 AOF 重写时，子进程会生成 RDB 快照存在 AOF 文件中，接下来主进程的命令会以追加的形式写入到 AOF 文件中，所以 AOF 文件就变成 RDB 和 AOF 的组合。

### 简单描述AOF重写流程

AOF重写时，父进程会 fork 一个子进程，当有新的命令执行时，会触发写时复制，会复制修改数据的副本给子进程，子进程将内存数据写入到 AOF 日志中，新的命令会由主进程写入到 AOF 缓冲区和 AOF 重写缓冲区，当子进程重写完后，会发送信号给主进程，主进程会将 AOF 重写缓冲区的命令追加到新的 AOF 文件中，然后新的文件替换旧的文件。

### AOF重写你觉得有什么不足之处么？

额外的 CPU 开销：主进程会将新的命令写入到 AOF 缓冲区和 AOF 重写缓冲区，并且通过管道发送给子进程，子进程再写入到新的 AOF 文件。

- 额外的内存开销：在 AOF 缓冲区和 AOF 重写缓冲区中写入了相同的操作。
- 额外的磁盘开销：AOF 缓冲区的内容写入到旧的 AOF 文件中，AOF 重写缓冲区的内容写入到新的 AOF 文件中，重写过程中，磁盘会多一份相同数据。
- 可能会阻塞主进程：如果在 fork 的过程中，数据量过大，会对主进程造成阻塞。

### 针对AOF重写的不足，你有什么优化思路呢？

可以采用 MP-AOF 的方案，将基础的命令存在一个base文件中，将新增的命令存在incr文件中，最终将base和incr文件结合就是新的 AOF 文件，可以减少 CPU、内存、磁盘的使用。同时如果写入时间过程、写入文件较大，可以采用集群的方式，将操作分散到多个节点上去。

补充：将 AOF 日志拆分成 Base AOF 和 Incr AOF，由 manifest 管理，重写时，会开一个子进程，对 Base AOF 重写，新的命令会写入到 Incr AOF 中，最后将 Base AOF 和 Incr AOF 结合就是新的 AOF 日志。

## Redis场景

### 你有实际使用过Redis做什么应用么？

有用过 Redis 做 MySQL 的缓存设计；做简单秒杀系统、在线聊天的消息队列；用 Hash 数据结构，以key-field-value的值来存储多级信息；用 ZSet 数据结构存储贴蛾子分数和帖子下逆袭，对投票的时间和分数进行设计，返回最热帖子。

### Redis缓存是如何应用的？

1. 可以缓存热点数据：频繁查询的数据可以缓存在 Redis 中，避免去数据库查询；
2. 可以缓存大计算结果：将计算过的结果缓存，避免庞大的计算量导致程序耗时、阻塞；
3. 可以做消息队列：将消息、执行指令、数据缓存在队列中，可以用作通信和流量设计。

### Redis做旁路缓存，如果MySQL更新了，此时何去何从？

写操作要先更新 MySQL，再删除缓存，其他顺序会导致数据不一致的问题。

补充：但是要保证 Redis 删除缓存成功，如果删除缓存失败，则仍然会出现数据不一致的问题，所以要增加重拾机制或者订阅 MySQL binlog，再操作缓存。

重拾机制可以用消息队列，将删除操作加入到消息队列中，由消费者操作数据。如果删除失败，可以从消息队列中重新读取数据，再次尝试删除，如果一定次数还是失败，就要向上游返回报错。如果删除成功，则从消息队列中删除该数据。

订阅 MySQL binlog 的流程是，先更新 MySQL 会产生一条日志，记录在 binlog 里。所以可以订阅 binlog 日志拿到具体的操作，阿里巴巴开源的 Canal 就是基于这个思想实现的。

### Redis做秒杀场景可以吗？讲讲思路

可以做，但并不是非常好的选择。用 Redis做秒杀场景可以用在两个方案，第一种方案做本地和远程的缓存设计，比如抢票系统中，总共有10000张票，如果主服务器的压力过大，可以将10000张票分散到各个从服务器的本地处理，可以使用lua的原子性设计，本地redis修改同步修改远程的票数据，不过redis存在一致性问题，可以更换etcd来保证强一致性；第二种方案是做消息队列，来做执行命令的通信，比如商品信息的秒杀，可以将商品订单信息、商品下单执行指令等请求推入消息队列中，并交给逻辑执行层来取出处理。

补充：Redis 可以用来记录库存，利用 Redis 的高性能进行库存的扣减，一个 Redis 处理 6W 的请求不大，100W/s 流量就 20台 Redis 来支撑，当然，每个节点都要做主从容灾。另一个方式就是把 Redis 作为轻量级消息队列，来接受请求，但是不如 kafka 这种可靠。

### Redis可以做消息队列吗？什么时候能用Redis做消息队列？

可以做，但是 Redis 的消息队列，会存在丢失消息的问题，比如在 AOF 持久化过程中，如果出现故障，可能会存在数据丢失，而且当消息队列中的数据信息积压时，会删除旧信息。

如果业务场景对数据丢失不敏感且不会存在消息积压的情况，可以使用Redis做消息队列。

### 分布式锁实现要点是什么（其实就是怎么加锁、怎么解锁、怎么用）？

Redis 的分布式锁实现主要是通过 SETNX 这条指令来执行的，当 key 不存在则插入成功，当 key 存在则插入失败。解锁用 del 指令删除 key 即可。

不过在执行加锁操作的时候要添加唯一的 id 来保证，谁加锁，谁解锁，避免释放了别人的锁。同时也要加上过期时间，避免某个客户端一直持有锁，发生异常后，锁无法释放。过期时间不好设置，可以采用续约的防治，防止锁失效被其他人抢占，续约的方式可以采用守护线程或者开一个协程watch监控，在锁快失效的时候重置过期时间。

解锁的时候，需要使用lua脚本保证判断锁是否是自己持有的锁和解锁操作的原子性。

但是主从复制的时候会存在一种情况，主节点加锁后，没有来得及同步给从节点，主节点就宕机了，此时可能出现其他人也获取到锁的情况，这种情况可以采用 redlock 的方案，即向集群内的多个节点申请加锁，如果超过半数以上加锁成功，则认为获取到锁。
