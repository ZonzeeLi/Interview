## 面试问题分类

### 操作系统

### 计算机网络

#### 基础内容

##### 1. TCP/IP 网络模型有几层？

- 应用层 : 为用户提供功能，比如HTTP、FTP、Telnet、DNS、SMTP等，当两个不同的设备需要通信，应用把数据传递给下一层。
- 传输层 : 为应用层提供网络支持，传输层的两种传输协议TCP和UDP。设备作为发送方，应用把数据给传输层再到下一层，作为接收方则反过来。
- 网络层 : 将数据从一个设备传输到另一个设备。最常使用的是IP协议。
- 网络接口层 : 为网络层提供「链路级别」传输的服务，负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标识网络上的设备。

##### 2. 键入网址到网页显示，期间发生了什么？

##### 3. Linux系统是如何收发网络包的？

###### 3.1 网络模型

OSI 七层模型 : 应用层、表示层、会话层、传输层、网络层、数据链路层、物理层
TCP/IP 四层模型 : 应用层、传输层、网络层、网络接口层

###### 3.2 Linux接收网络包的流程

当网卡接收到网络包后，通过DMA技术，将网络包放到Ring Buffer，当网络包到达，网卡发起硬件中断，执行中断处理函数，发出一个「软中断」来轮询处理数据，直到没有新数据恢复中断，一次中断处理多个网络包。

软中断处理网络包是从 Ring Buffer 中拷贝数据到内核 struct sk_buff 缓冲区中，从而可以作为一个网络包交给网络协议栈进行逐层处理。

首先，进入网络接口层，检查报文合法性，合法找到上层协议类型，比如是IPv4，或者是IPv6，去掉帧头和帧尾，到网络层。

取出IP包，判断网络包下一步是继续上层处理还是转发出去，如果网络包是发送给本机的，就会从IP头里查看再上一层使用的是TCP还是UDP，去掉IP头，到传输层。

取出TCP或UDP头，根据「源 IP、源端口、目的 IP、目的端口」找出对应的Socket，将数据拷贝到Socket的接收缓冲区。

最后，应用层调用Socket接口，从内核的Socket接收缓冲区读取新数据到应用层。

###### 3.3 Linux发送网络包的流程

和上述接收网络包的过程正好相反。

##### 4. TCP和UDP的区别？

#### HTTP

##### 1. HTTP 基本概念

###### 1.1 HTTP 是什么？

HTTP 是超文本传输协议。是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。

###### 1.2 HTTP 常见的状态码

- 200 OK : 常见的成功状态码，如果是非 HEAD 请求，服务器返回的响应头都会有 body 数据。
- 204 No Content : 常见的成功状态码，响应头没有 body 数据。
- 206 Partial Content : 是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。
- 301 Moved Permanently : 永久重定向。
- 302 Found : 临时重定向。说明请求的资源还在，但暂时需要用另一个 URL 来访问。301 和 302 都会在响应头里使用字段 Location，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。
- 304 Not Modified : 不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。
- 400 Bad Request : 客户端请求的报文有误。
- 403 Forbidden : 服务器禁止访问。
- 404 Not Found : 请求的资源在服务器上不存在或未找到，所以无法提供给客户端。
- 500 Internal Server Error : 服务器发生错误。
- 501 Not Implemented : 客户端请求的功能还不支持。
- 502 Bad Gateway : 通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。
- 503 Service Unavailable : 服务器当前很忙，暂时无法响应客户端。

###### 1.3 HTTP 常见的字段

- Host 字段 : 服务器的域名。
- Content-Length 字段 : 回应的数据长度。
- Connection 字段 : 最常用的是要求服务器使用 TCP 的持久连接，即 Keep-Alive 。HTTP/1.1 版本的默认连接都是持久连接。
- Content-Type 字段 : 用于服务器回应时，告诉客户端，本次数据是什么格式。
- Content-Encoding 字段 : 数据的压缩方法。表示服务器返回的数据使用了什么压缩格式。

##### 2. GET 与 POST

###### 2.1 GET 与 POST 的区别

GET 的语义是从服务器获取指定的资源，一般是写在 URL 中，浏览器会对 URL 的长度有限制。POST 的语义是根据请求负荷(报文 body )对指定的资源作出处理，不会对 body 大小做出限制。

###### 2.2 GET 和 POST 方法都是安全和幂等的吗？

安全 : 不会破坏服务器上的资源。
幂等 : 多次执行相同的操作，结果都是相同的。

- GET : 安全且幂等的，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。所以，可以对 GET 请求的数据做缓存，这个缓存可以做到浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如nginx），而且在浏览器中 GET 请求可以保存为书签。
- POST : 是「新增或提交数据」的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据就会创建多个资源，所以不是幂等的。所以，浏览器一般不会缓存 POST 请求，也不能把 POST 请求保存为书签。

不过实际过程中可能使用 GET 来实现新增或删除，POST 查询数据，这样的话就不一定了，而且虽然 POST 是用 body 传输数据，但是抓个包就可以看到数据，也不一定就比 GET 方法安全，所以要用 HTTPS 协议加密传输。

##### 3. HTTP 缓存技术

###### 3.1 强制缓存

强制缓存指的是只要浏览器判断缓存没有过期就直接使用浏览器的本地缓存，决定是否使用缓存的主动性在于浏览器这边。

强缓存使用的是两个 HTTP 响应头部字段实现，用来表示资源在客户端缓存的有效期。

- Cache-Control : 是一个相对时间。
- Expires : 是一个绝对时间。

如果头部同时存在这两个字段的话，Cache-Control 的优先级高于 Expires 。

Cache-control 选项更多一些，设置更加精细，所以建议使用 Cache-Control 来实现强缓存。具体的实现流程如下：

- 当浏览器第一次请求访问服务器资源时，服务器返回资源的同时，响应头部会添加上 Cache-Control，这里设置了过期时间的大小。
- 当浏览器再次请求访问服务器资源时，会先通过请求资源的时间与 Cache-Control 中设置的过期时间大小，计算是否过期，如果没有，则使用缓存，否则重新请求。
- 服务器再次收到请求后，会更新响应头部的 Cache-Control。

###### 3.2 协商缓存

协商缓存就是与服务端协商之后，通过协商结果来判断是否使用本地缓存。

协商缓存基于两种头部来实现，第一种是请求头部中的 If-Modified-Since 字段与响应头部中的 Last-Modified 字段。

- 响应头部中的 Last-Modified : 表示这个响应资源的最后修改时间。
- 请求头部中的 If-Modified-Since : 当资源过期了，发现响应头中具有 Last-Modified 声明，则再次发起请求的时候带上  Last-Modified 的时间，服务器收到请求后发现有 If-Modified-Since 则与被请求资源的最后修改时间进行比较，如果最后修改时间较新，说明资源被修改过，返回最新资源；如果最后修改时间较早，说明无新修改，返回 304 走本地缓存。

第二种是请求头部中的 If-Modified-Since 字段与响应头部中的 Last-Modified 字段实现。

- 响应头部中的 Etag : 唯一标识响应资源。
- 请求头部中的 If-None-Match : 当本地缓存资源过期时，浏览器发现响应头里有 Etag，则再次向服务器发送请求时，会将请求头中 If-None-Match 值设置为 Etag 的值。服务器收到请求后进行比对，如果资源没有变化返回 304 状态码，如果有变化返回 200。

第一种是基于时间实现的，第二种是基于唯一标识，相对来说后者更加准确的判断文件内容是否被修改，避免由于时间篡改导致的不可靠问题。

如果 HTTP 响应头部中同时存在 Etag 和 Last-Modified 字段的时候，Etag 的优先级更高，先判断 Etag 是否发生了变化，如果没有变化，则继续看 Last-Modified。

注意，协商缓存的字段需要配合强制缓存中 Cache-control 字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求。

使用 Etag 字段实现的协商缓存过程如下 : 

- 当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在响应头部添加 Etag 唯一标识，这个唯一标识的值是根据当前请求的资源生成。
- 当浏览器再次请求访问服务器该资源时，首先检查强制缓存是否国企，如果没过期则直接使用本地缓存；如果过期，则在请求头部加上 If-None-Match 字段，该字段的值就是 ETag 唯一标识。
- 服务器再次收到请求后，会根据请求中的 If-None-Match 值与当前请求的资源生成的唯一标识进行比较：
  - 如果值相等，则返回 304 Not Modified，不会返回资源；
  - 如果不相等，则返回 200 状态码和资源，并在响应头部加上新的 ETag 唯一标识；
- 如果浏览器收到的是 304 请求响应状态码，则会从本地缓存中加载资源，否则更新。

##### 4. HTTP 特性

###### 4.1 HTTP 1.1 的优点有哪些？

1. 简单

HTTP 的基本报文格式是 header + body ，头部信息也是 key-value 简单文本的形式，易于理解，降低了学习的门槛。

2. 灵活和易于扩展

HTTP 协议里的各类请求方法、URI / URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发人员自定义和扩充。

同时 HTTP 由于是工作在应用层( OSI 第七层)，则它下层可以随便变化。

HTTPS 就是在 HTTP 与 TCP 层之间增加了 SSL / TLS 安全传输层，HTTP / 3把 TCP 层换成了基于 UDP 的 QUIC。

3. 应用广泛和跨平台

互联网发展至今，HTTP 的应用范围非常的广泛，从台式机的浏览器到手机上的各种 APP，从看新闻、刷贴吧到购物、理财、吃鸡，HTTP 的应用遍地开花，同时天然具有跨平台的优越性。

###### 4.2 HTTP 1.1 的缺点有哪些？

1. 无状态双刃剑

无状态的好处，因为服务器不会记忆 HTTP 的状态，所以不需要额外的资源来记录状态信息，这能减轻服务器的负担，能够把更多的 CPU 和内存用来对外提供服务。

无状态的坏处，既然服务器没有记忆能力，再完成有关联性的操作会很麻烦，比如一套购物流程，从登陆到下单到付款等，都需要验证用户身份，如果服务器不知道这些请求是关联的，每次都要验证一遍。比较简单的解决这一问题的方法就是 Cookie 技术。

Cookie 通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。相当于，在客户端第一次请求后，服务器下发一个带有客户信息的字段，下次客户端请求服务器，带上该字段，服务器就能认得了。

2. 明文传输双刃剑

明文意味着传输中的信息是可方便阅读的，通过 F12 控制台或者抓包可以直接查看，为调试带来了极大的便利性。

不过这样也相当于信息裸奔，在传输的过程中很容易被窃取。

3. 不安全

HTTP 比较严重的缺点就是不安全 : 

- 通信使用明文，内容会被窃听。
- 不验证通信放的身份，会遭遇伪装。
- 无法验证报文的完整性，有可能被篡改。

###### 4.3 HTTP 1.1 的性能如何？

1. 长连接

早期 HTTP 1.0 性能上的一个很大问题，就是没发一次请求，都要新建一次 TCP 连接，而且是串行请求，做了无所谓的 TCP 连接和断开，增加了通信的开销。

HTTP 1.1 提出了长连接的通信方式，也叫持久连接。这种方式的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。

持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。

如果某个 HTTP 长连接超过一定时间没有任何数据交互，服务端就会主动断开。

2. 管道网络传输

在可在同一个 TCP 连接里面，客户端发起多个请求，只要第一个请求发出去了，不必等其回来，可以发送第二个请求出去，减少整体的响应时间。

但是服务器必须按照接收请求的顺序发送对这些管道化请求的响应。如果服务端在处理 A 请求耗时比较长，那么后续的请求处理都会被阻塞住，也就是队头阻塞。HTTP 1.1 解决了请求的队头阻塞，但是并没有解决响应的队头阻塞。

3. 队头阻塞

「请求 - 应答」的模式加剧了 HTTP 的性能问题。当顺序发送的请求序列，某一个请求因为某种原因被阻塞，后面的排队的请求就会一直被阻塞，这就是队头阻塞，类似于上班塞车。

##### 5. HTTP 与 HTTPS 

###### 5.1 HTTP 与 HTTPS 有哪些区别？

1. HTTP 是超文本传输协议，信息是明文传输，存在安全问题。HTTPS 则解决了 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL / TLS 安全协议，让报文加密传输。
2. HTTP 连接建立比较简单，TCP 三次握手之后即可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后要进行 SSL / TLS 握手过程，再进行加密的报文传输。
3. HTTP 的端口号是 80，HTTPS 的端口号是 443。
4. HTTPS 要向 CA（证书权威机构）申请数字证书，来保证服务器的身份可信。

###### 5.2 HTTPS 解决了 HTTP 的哪些问题？

HTTP 由于是明文传输，所以存在以下三个风险：

- 窃听风险，比如通信链路上可以获取通信内容。
- 篡改风险，比如强制植入垃圾广告。
- 冒充风险，比如冒充淘宝网站。

HTTPS 在 HTTP 和 TCP 之间加入了 SSL/TLS 协议，解决了以上问题。

- 信息加密 : 交互信息无法被窃取。
- 校验机制 : 无法篡改通信内容，篡改了就不能正常显示。
- 身份证书 : 证明网站时真正要浏览的网站。

###### 5.3 HTTPS 时如何解决以上的三个风险问题？

- 混合加密的方式实现了信息的机密性，解决了窃听的风险。
- 摘要算法的方式实现了完整性，为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。
- 将服务器公钥放入到数字证书中，解决了冒充的风险。

1. 混合加密

HTTPS 采用的是对称加密和非对称加密结合的「混合加密」方式：

- 在通信建立之前使用非对称加密的方式交换「会话秘钥」，后续不再使用非对称加密。
- 在通信的过程中全部使用对称加密的「会话秘钥」的方式加密明文数据。

采用「混合加密」的原因：

- 对称加密只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。
- 非对称加密使用两个密钥，公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换的问题，但是速度会慢。

2. 摘要算法

摘要算法实现完整性，客户端发送明文前通过摘要算法算出明文的「指纹」，发送的时候把「指纹 + 明文」一同加密成密文后，发送给服务器，服务器解密后，用相同的摘要算法算出发送过来的明文，通过比较客户端携带的「指纹」和当前算出的「指纹」做比较，若「指纹」相同，说明数据是完整的。

3. 数字证书

客户端向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用私钥解密。借助第三方权威机构 CA（数字证书认证机构），将服务器的公钥放在数字证书中，只要证书是可信的，公钥就是可信的。

###### 5.4 HTTPS 是如何建立连接的？其间交互了什么？

SSL / TLS 协议基本流程 :

- 客户端向服务器索要并验证服务器的公钥。
- 双方协商生产「会话秘钥」。
- 双方采用「会话秘钥」进行加密通信。

SSL / TLS 协议详细流程 :

1. ClientHello 

首先，客户端向服务器发起加密通信请求，即 ClientHello 请求。客户端主要发送以下信息给服务器：
（1）客户端支持的 SSL / TLS 协议版本。
（2）客户端生成的随机数 ( Client Random )，后面用户生成会话密钥条件之一。
（3）客户端支持的密码套件列表。

2. SeverHello

服务器收到客户端请求后，向客户端发出响应，即 SeverHello 。服务器回应的内容如下：
（1）确认 SSL / TLS 协议版本，如果浏览器不支持，则关闭加密通信。
（2）服务器生成的随机数 ( Server Random )，也是后面用户生产「会话秘钥」条件之一。
（3）确认的密码套件列表。
（4）服务器的数字证书。

3. 客户端回应

客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。

如果证书没有问题，客户端会从数字证书中取出服务器的公钥，然后使用它加密报文，向服务器发送如下信息：
（1）一个随机数 ( pre-master key )。该随机数会被服务器公钥加密。
（2）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。
（3）客户端握手结束同值，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。

上面第一项的随机数是整个握手阶段的第三个随机数，会发送给服务端，所以这个随机数客户端和服务端都是一样的。

服务端和客户端有了这三个随机数 ( Client Random、Server Random、pre-master key )，接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」。

4. 服务器的最后回应

服务器收到客户端的第三个随机数 ( pre-master key ) 之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。然后向客户端发送最后的信息如下：
（1）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。
（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内瓤的发生的数据做个摘要，用来供客户端校验。

至此，整个 SSL / TLS 的握手阶段全部结束。接下来客户端与服务器进入加密通信，使用的是普通的 HTTP 协议，只不过用「会话秘钥」加密内容。

![HTTPS流程图（图源小林coding）](https://github.com/ZonzeeLi/Interview/blob/master/picture/HTTPS%E6%B5%81%E7%A8%8B.png)

##### 6. HTTP /1.1、HTTP /2、HTTP /3 演变

###### 6.1 HTTP /1.1 相比 HTTP /1.0 提高了什么性能？

HTTP /1.1 相比 HTTP /1.0 性能上的改进：

- 使用 TCP 长连接的方式改善了 HTTP /1.0 短连接造成的性能开销。
- 支持管道( pipeline )网络传输，只要第一个请求发出去了，不必等其回来，就可以发送第二个请求，减少整体的响应时间。

HTTP /1.1 的性能瓶颈：

- 请求 / 响应头部 ( Header ) 未经压缩就发送，首部信息越多延迟越大。只能压缩 Body 部分
- 发送冗长的首部。每次互相发送相同的首部造成过多浪费。
- 服务器是按请求的顺序响应的，如果服务器响应慢，则会招致客户端一直请求不到数据，也就是队头阻塞。
- 没有请求优先级控制。
- 请求只能从客户端开始，服务器只能被动响应。

###### 6.2 HTTP /2 做了什么优化？

HTTP /2 协议是基于 HTTPS 的，所以 HTTP /2 的安全性也是有保障的。

HTTP /2 相比 HTTP /1.1 性能上的改进：

1. 头部压缩

HTTP /2 会压缩头 ( Header )，如果同时发出多个请求，他们的头是一样的或者详细的，那么协议会消除重复的部分。

这就是 HPACK 算法：在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高了速度。

2. 二进制格式

HTTP /2 不再像 HTTP /1.1 里的纯文本形式的报文，而是全面采用了二进制格式，头信息和数据体都是二进制，并且统称为帧 ( frame )：头信息帧 ( Headers Frame ) 和数据帧 ( Data Frame )。

这样虽然对人不友好，但是计算机只懂二进制，无需将明文的报文再转成二进制，而是直接解析，增加了数据传输的效率。

3. 数据流

HTTP /2 的数据包不是按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。

在 HTTP /2 中每个请求或响应的所有数据包，称为一个数据流 ( Stream )。每个数据流都标记着一个独一无二的编号 ( Stream ID )，不同的 Stream 的帧是可以乱序发送的，因此可以并发不同的 Stream，因为每个帧的头部会携带 Stream ID 信息，所以接收端可以通过 Stream ID 有序组装成 HTTP 消息。

客户端和服务器双方都可以建立 Stream，Stream ID 也是有区别的，客户端建立的 Stream 必须是奇数号，而服务器建立的 Stream 必须是偶数号。

客户端还可以指定数据流的优先级，优先级高的请求，服务器就先响应该请求。

4. 多路复用

HTTP /2 是可以在一个连接中并发多个请求或响应，而不用按照顺序一一对应。

移除了 HTTP /1.1 中的串行请求，不需要排队等待，也就不会再出现「队头阻塞」问题，降低了延迟，大幅度提高了连接的利用率。

5. 服务器推送

HTTP /2 还在一定程度上改善了传统的「请求 - 应答」工作模式，服务不再是被动地响应，也可以主动向客户端发送消息。

HTTP /2 有什么缺陷：

HTTP /2 通过 Stream 的并发能力，解决了 HTTP /1 的队头阻塞的问题，看似很完美了，但是 HTTP /2 还是存在该问题，不过不是发生在 HTTP 这一层面，而是 TCP 这一层。

HTTP /2 是基于 TCP 协议来传输数据的，TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区里的数据返回给 HTTP 应用，那么当「前 1 个字节数据」没有到达时，后收到的字节数据只能存放在内核缓冲区里，只有等到这 1 个字节数据到达时，HTTP/2 应用层才能从内核中拿到数据，这就是 HTTP /2 队头阻塞问题。

所以一旦发生了丢包现象，就会触发 TCP 的重传机制，这样在一个 TCP 连接中的所有的 HTTP 请求都必须等待这个丢了的包被重传回来。

###### 6.3 HTTP /3 做了哪些优化？

上述说明了 HTTP /1.1 和 HTTP /2 都有队头阻塞的问题：

- HTTP /1.1 中的管道 ( pipeline ) 虽然解决了请求的队头阻塞，但是没有解决响应的队头阻塞，因为服务端需要按照顺序响应收到的请求，如果服务端处理某个请求消耗的时间比较长，那么只能等响应处理完这个请求后，才能处理下一个请求，属于 HTTP 层的队头阻塞。
- HTTP /2 虽然通过多个请求复用一个 TCP 连接解决了 HTTP 的队头阻塞，但是一旦发生丢包，就会阻塞住所有的 HTTP 请求，这属于 TCP 层队头阻塞。

HTTP /3 把 HTTP 下层的 TCP 协议改成了 UDP。

UDP 不管顺序，也不管丢包，不会出现 HTTP /2 队头阻塞的问题。基于 UDP 的 QUIC 协议可以实现类似 TCP 的可靠性传输。

QUIC 有以下3个特点：

1. 无队头阻塞

QUIC 协议也有类似 HTTP /2 Stream 与多路复用的概念，也是可以在同一条连接上并发传输多个 Stream，Stream 可以认为是一条 HTTP 请求。

QUIC 有自己的一套机制可以保证传输的可靠性。当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响，因此不存在队头阻塞问题。这与 HTTP /2 不同，HTTP /2 只要某个流中的数据包丢失了，其他流也会受到影响。

所以，QUIC 连接上的多个 Stream 之间并没有依赖，都是独立的，某个流发生丢包了，只会影响该流，其他流不受到影响。

2. 更快的连接建立

对于 HTTP /1 和 HTTP /2 协议，TCP 和 TLS 是分层的，分别属于内核实现的传输层、openssl 库实现的表示层，因此他们难以合并在一起，需要分批次来握手，先 TCP 握手，再 TLS 握手。

HTTP /3 在传输数据前虽然需要 QUIC 协议握手，这个握手过程只需要 1 RTT，握手的目的是为确认双方的「连接 ID」，连接迁移就是基于连接 ID 实现的。

但是 HTTP /3 的 QUIC 协议并不是与 TLS 分层，而是 QUIC 内部包含了 TLS，它在自己的帧会携带 TLS 里的“记录”，再加上 QUIC 使用的是 TLS /1.3，因此仅需要 1 个 RTT 就可以「同时」完成建立连接与密钥协商。甚至在第二次连接的时候，数据包和 QUIC 握手信息 ( 连接信息 + TLS 信息 ) 一起发送，达到 0-RTT 的效果。

3. 连接迁移

基于 TCP 传输协议的 HTTP 协议，由于是通过四元组（源 IP、源端口、目的 IP、目的端口）确定一条 TCP 连接，那么当移动设备的网络从 4G 切换到 WIFI 时，意味着 IP 地址变化了，那么就必须要断开连接，然后重新建立连接。而建立连接的过程中包含 TCP 三次握手和 TLS 四次握手的时延，以及 TCP 慢启动的减速过程，给用户的感觉就是网络卡顿了一下，因此连接的迁移成本很高。

而 QUIC 协议没有四元组的方式来“绑定”连接，而是通过连接 ID 来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此计是移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID，TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本，没有丝毫卡顿，达到了连接迁移的效果。

所以 QUIC 是一个在 UDP 之上的伪 TCP + TLS + HTTP /2 的多路复用协议。

##### 7. HTTP /1.1 如何优化？

可以从以下三种优化思路来优化 HTTP /1.1 协议：

- 尽量避免发送 HTTP 请求
- 在需要发送 HTTP 请求时，考虑如何减少请求次数
- 减少服务器的 HTTP 响应的数据大小

第一个思路是，通过缓存技术来避免发送 HTTP 请求。客户端收到第一个请求的响应后，可以将其缓存在本地磁盘，下次请求的时候，如果缓存没过期，就直接读取本地缓存的响应数据。如果缓存过期，客户端发送请求的时候带上响应数据的摘要，服务器比对后发现资源没有变化，就发出不带包体的 304 响应，告诉客户端缓存的响应仍然有效。

第二个思路是，减少 HTTP 请求的次数，有以下的方法：

1. 将原本由客户端处理的重定向请求，交给代理服务器处理，这样可以减少重定向请求的次数；
2. 将多个小资源合并成一个大资源再传输，能够减少 HTTP 请求次数以及 头部的重复传输，再来减少 TCP 连接数量，进而省去 TCP 握手和慢启动的网络消耗；
3. 按需访问资源，只访问当前用户看得到/用得到的资源，当客户往下滑动，再访问接下来的资源，以此达到延迟请求，也就减少了同一时间的 HTTP 请求次数。

第三思路是，通过压缩响应资源，降低传输资源的大小，从而提高传输效率，所以应当选择更优秀的压缩算法。

###### 7.1 如何避免发送 HTTP 请求？

对于一些重复性的 HTTP 请求，比如每次请求得到的数据都一样的，可以把这些「请求-响应」的数据都缓存在本地，下次直接读取本地的数据，不必通过网络获取服务器的响应。所以避免 HTTP 请求的方法就是通过缓存技术。

客户端会把第一次请求以及响应的数据保存在本地磁盘上，其中将请求的 URL 作为 key，而响应作为 value，两者形成映射关系。

服务器在发送 HTTP 响应时，会估算一个过期的时间，并且把这个信息放到响应头部，客户端在查看响应头部的信息时，一旦发送缓存的响应是过期的，则就会重新发送网络请求。而如果客户端第一次请求得到的响应头部中发现该响应过期了，客户端重新发送请求，服务器上的资源没有变更，则服务器没有必要在响应中再带上这个资源。只需要客户端在重新发送请求时，在请求的 Etag 头部带上第一次请求响应的头部中的摘要，这个摘要时唯一标识响应的资源，当服务器收到请求后，会将本地资源的摘要与请求中的摘要做比较。如果不同，说明客户端的缓存没有价值，重新带上资源，而如果相同，服务器返回不带有 body 的 304 Not Modified 响应，告诉客户端仍然有效，减少响应资源在网络中传输的延时。缓存真的是性能优化的一把万能钥匙，小到 CPU Cache、Page Cache、Redis Cache，大到 HTTP 协议的缓存。

###### 7.2 如何减少 HTTP 请求次数？

1. 减少重定向请求次数

服务器上的一个资源由于迁移维护等原因从一个地址迁至另一个地址，但是客户端不知道，继续请求第一个地址，这时服务器应当返回 302 响应码和 Location 头部，告诉客户端该资源迁至另一个地址了。

如果重定向请求越多，客户端发起的 HTTP 请求就越多。而且服务端一般不只有一台服务器，比如源服务器上一级是代理服务器，然后代理服务器与客户端进行通信，这时客户端重定向会导致客户端与代理服务器之间需要 2 次消息传递。如果重定向的工作交由代理服务器完成，就能减少 HTTP 请求次数了，而且当代理服务器知晓了重定向规则后，可以进一步减少消息传递次数。

2. 合并请求

如果把多个访问小文件的请求合并成一个大请求，虽然传输的总资源一样，但减少请求就减少了重复发送的 HTTP 头部。另外 HTTP /1.1 如果第一发送的请求阻塞，后续的请求就不会发送，为了防止单个请求阻塞，一般浏览器会同时发起 5-6 个请求，每一个都是不同的 TCP 连接，如果合并了请求，就会减少 TCP 连接的数量，省去了 TCP 握手和慢启动过程耗费的时间。

比如可以通过将多个小图片合并成一个大图片来减少 HTTP 请求的次数，以减少 HTTP 请求的次数，从而减少网络的开销。也有服务端使用 webpack 等打包工具将资源合并打包成大文件的方法。所以合并请求的方式就是合并资源，以一个大资源的请求替换多个小资源的请求。

但这样子的合并请求会带来新问题，当大资源中的某一个小资源发生改变后，客户端必须重新下载整个完整的大资源文件。

3. 延迟发送请求

一般 HTML 里会含有很多 HTTP 的 URL，当前不需要的资源，没必要请求，按需获取，减少第一时间的 HTTP 请求次数。请求网页时，没必要把全部资源获取到，只获取当前用户所看到的页面资源，当用户向下滑动页面的时候，再向服务器获取接下来的资源，达到延迟发送请求的效果。

###### 7.3 如何减少 HTTP 响应的数据大小？

1. 无损压缩

无损压缩是指资源经过压缩后，信息不被破坏，还能完全恢复到压缩前的原样，适合用在文本文件、程序可执行文件、程序源代码。

2. 有损压缩

有损压缩主要将次要的数据舍弃，牺牲一些质量来减少数据量、提高压缩比，这种方法经常用于压缩多媒体数据，比如音频、视频、图片。

##### 8. HTTPS RSA 握手解析

###### 8.1 RSA 握手过程

传统的 TLS 握手基本都是使用 RSA 算法来实现密钥交换的，在将 TLS 证书部署服务端时，证书文件中包含一对公私钥，其中公钥会在 TLS 握手阶段传递给客户端，私钥则一直留在服务端，一定要确保私钥不能被窃取。

在 RSA 密钥协商算法中，客户端会生成随机密钥，并使用服务端的公钥加密后再传给服务端。根据非对称加密算法，公钥加密的消息仅能通过私钥解密，这样服务端解密后，双方就得到了相同的密钥，再用它加密应用消息。

1. TLS 第一次握手

客户端首先会发一个「Client Hello」消息，有客户端使用的 TLS 版本号、支持的密码套件列表，以及生成的随机数 ( Client Random )，这个随机数会被服务端保留，是生成对称加密密钥的材料之一。

2. TLS 第二次握手

当服务端收到客户端的「Client Hello」消息后，会确认 TLS 版本号是否支持，和从密码套件列表中选择一个密码套件，以及生成随机数 ( Server Random )。接着，返回「Server Hello」消息，消息里面有服务器确认的 TLS 版本号，也给出了随机数 ( Server Random )，然后从客户端的密码套件列表选择了一个合适的密码套件。客户端和服务端的两个随机数是后续作为生成「会话密钥」的条件，所谓的会话密钥就是数据传输时，所使用的对称加密密钥。

然后，服务端为了证明自己的身份，会发送「Server Certificate」给客户端，这个消息里含有数字证书。

随后，服务端发了「Server Hello Done」消息，目的是告诉客户端，我已经把该给你的东西都给你了，本次打招呼完毕。

3. TLS 第三次握手

客户端验证完证书后，可信则继续向下。接着，客户端会生成一个新的随机数 ( pre-master )，用服务器的 RSA 公钥加密该随机数，通过「Change Cipher Key Exchange」消息传给服务端。服务端收到后，用 RSA 私钥解密，得到客户端发来的随机数 ( pre-master )。

至此，客户端和服务端双方都共享了三个随机数，分别是 Client Random、Server Random、pre-master。根据这三个随机数生成会话密钥 ( Master Secret )，它是对称密钥，用于对后续的 HTTP 请求 / 响应的数据加解密。生成完会话密钥，然后客户端发一个「Change Cipher Spec」，告诉服务端开始使用加密方式发送消息。然后客户端再发一个「Encrypted Handshake Message ( Finishd ) 」消息，把之前所有发送的数据做个摘要，再用会话密钥 ( master secret ) 加密一下，让服务器做个验证，验证加密通信是否可用和之前握手信息是否有被中途篡改过。可以发现，「Change Cipher Spec」之前传输的 TLS 握手数据都是明文，之后都是对称密钥加密的密文。

4. TLS 第四次握手

服务器也是同样的操作，发「Change Cipher Spec」和「Encrypted Handshake Message」消息，如果双方都验证加密和解密没问题，那么握手正式完成。

最后，就用「会话密钥」加解密 HTTP 请求和响应了。

###### 8.2 RSA 算法的缺陷

使用 RSA 密钥协商算法的最大问题是不支持前向保密。

因为客户端传递随机数（用于生成对称加密密钥的条件之一）给服务端时使用的是公钥加密的，服务端收到到后，会用私钥解密得到随机数。所以一旦服务端的私钥泄漏了，过去被第三方截获的所有 TLS 通讯密文都会被破解。为了解决这个问题，后面就出现了 ECDHE 密钥协商算法。

##### 9. HTTPS ECDHE 握手

###### 9.1 ECDHE 握手过程

1. TLS 第一次握手

客户端首先会发一个「Client Hello」消息，消息里面有客户端使用的 TLS 版本号、支持的密码套件列表，以及生成的随机数 ( Client Random )。

2. TLS 第二次握手

服务端收到客户端的「打招呼」，同样也要回礼，会返回「Server Hello」消息，消息面有服务器确认的 TLS 版本号，也给出了一个随机数 ( Server Random )，然后从客户端的密码套件列表选择了一个合适的密码套件。不过和 RSA 的密码套件所表示的内容不太一样。然后服务器为了证明自己的身份，发送「Certificate」消息，会把证书也发给客户端。这一步就和 RSA 握手过程有很大的区别，因为服务端选择了 ECDHE 密钥协商算法，所以会在发送完证书后，发送「Server Key Exchange」消息。随后，就是「Server Hello Done」消息。

至此，TLS 两次握手就已经完成了，目前客户端和服务端通过明文共享了这几个信息：Client Random、Server Random 、使用的椭圆曲线、椭圆曲线基点 G、服务端椭圆曲线的公钥，这几个信息很重要，是后续生成会话密钥的材料。

3. TLS 第三次握手

客户端收到了服务端的证书后，自然要校验证书是否合法，如果证书合法，那么服务端到身份就是没问题的。校验证书的过程会走证书链逐级验证，确认证书的真实性，再用证书的公钥验证签名，这样就能确认服务端的身份了，确认无误后，就可以继续往下走。

客户端会生成一个随机数作为客户端椭圆曲线的私钥，然后再根据服务端前面给的信息，生成客户端的椭圆曲线公钥，然后用「Client Key Exchange」消息发给服务端。最终的会话密钥，就是用「客户端随机数 + 服务端随机数 + x（ECDHE 算法算出的共享密钥） 」三个材料生成的。

算好会话密钥后，客户端会发一个「Change Cipher Spec」消息，告诉服务端后续改用对称算法加密通信。接着，客户端会发「Encrypted Handshake Message」消息，把之前发送的数据做一个摘要，再用对称密钥加密一下，让服务端做个验证，验证下本次生成的对称密钥是否可以正常使用。

4. TLS 第四次握手

最后，服务端也会有一个同样的操作，发「Change Cipher Spec」和「Encrypted Handshake Message」消息，如果双方都验证加密和解密没问题，那么握手正式完成。于是，就可以正常收发加密的 HTTP 请求和响应了。

###### 9.2 RSA 和 ECDHE 握手过程的区别

- RSA 密钥协商算法「不支持」前向保密，ECDHE 密钥协商算法「支持」前向保密
- 使用 RSA 密钥协商算法，TLS 完成四次握手后，才能进行应用数据传输，而对于 ECDHE 算法，客户端可以不用等服务端的最后一次 TLS 握手，就可以提前发出加密的 HTTP 数据，节省了一个消息的往返时间
- 使用 ECDHE， 在 TLS 第 2 次握手中，会出现服务器端发出的「Server Key Exchange」消息，而 RSA 握手过程没有该消息

##### 10. HTTPS 如何优化？

###### 10.1 分析性能损耗

产生性能消耗的两个环节：

- 第一个环节，TLS 协议握手过程
- 第二个环节，握手后的对称加密报文传输

对于第二环节，现在主流的对称加密算法 AES、ChaCha20 性能都是不错的，而且一些 CPU 厂商还针对它们做了硬件级别的优化，因此这个环节的性能消耗可以说非常地小。

对于第一个环节，TLS 协议握手过程不仅增加了网络延时 ( 最长可以花掉 2 RTT )，而且握手过程中的一些步骤也会产生性能损耗，比如：

- 对于 ECDHE 密钥协商算法，握手过程中会客户端和服务端都需要临时生成椭圆曲线公私钥
- 客户端验证证书时，会访问 CA 获取 CRL 或者 OCSP，目的是验证服务器的证书是否有被吊销
- 双方计算 Pre-Master，也就是对称加密密钥

###### 10.2 硬件优化

HTTPS 协议是计算密集型，而不是 I/O 密集型，所以不能把钱花在网卡、硬盘等地方，应该花在 CPU 上。另外，如果可以，应该选择可以支持 AES-NI 特性的 CPU，因为这种款式的 CPU 能在指令级别优化了 AES 算法，这样便加速了数据的加解密传输过程。

###### 10.3 软件优化

软件优化的方向分为两种，一种是软件升级，一种是协议优化。软件升级就是把软件升级到最新的版本，而协议优化就是对「密钥交换过程」进行优化。

1. 密钥交换算法优化

RSA 密钥交换算法得 TLS 握手过程，不仅慢，而且安全性也不高。因此如果可以，尽量使用 ECDHE 密钥交换算法替换 RSA 算法，客户端可以在 TLS 协议的第 3 次握手后，第 4 次握手前，发送加密的应用数据，以此将 TLS 握手的消息往返由 2 RTT 减少到 1 RTT，而且安全性也高，具备前向安全性。

2. TLS 升级

如果可以，直接把 TLS 1.2 升级成 TLS 1.3，TLS 1.3 大幅度简化了握手的步骤，完成 TLS 握手只要 1 RTT，而且安全性更高。TLS 1.3 把 Hello 和公钥交换这两个消息合并成了一个消息，于是这样就减少到只需 1 RTT 就能完成 TLS 握手。TLS1.3 对密码套件进行“减肥”了，对于密钥交换算法，废除了不支持前向安全性的 RSA 和 DH 算法，只支持 ECDHE 算法。

###### 10.4 证书优化

对证书的优化，可以有两个方向，一个是证书传输，一个是证书验证。

1. 证书传输优化

要让证书更便于传输，那必然是减少证书的大小，这样可以节约带宽，也能减少客户端的运算量。所以，对于服务器的证书应该选择椭圆曲线（ECDSA）证书，而不是 RSA 证书，因为在相同安全强度下， ECC 密钥长度比 RSA 短的多。

2. 证书验证优化

客户端在验证证书时，是个复杂的过程，会走证书链逐级验证，验证的过程不仅需要「用 CA 公钥解密证书」以及「用签名算法验证证书的完整性」，而且为了知道证书是否被 CA 吊销，客户端有时还会再去访问 CA， 下载 CRL 或者 OCSP 数据，以此确认证书的有效性。

这个访问过程是 HTTP 访问，因此又会产生一系列网络通信的开销，如 DNS 查询、建立连接、收发数据等。

CRL 称为证书吊销列表 ( Certificate Revocation List )，这个列表由 CA 定期更新，列表内容是撤销信任的证书序号，如果服务器的证书在则会个列表中，说明证书失效，不在的话，认为证书有效。

- 第一个问题，由于 CRL 列表由 CA 维护，定期更新，如果一个证书被吊销后，客户端在更新 CRL 之前还是会信任这个证书，实时性较差
- 第二个问题，随着吊销证书的增多，列表会越来越大，下载速度会越来越慢，下载完客户端还要遍历列表，会导致校验证书这一环节的延时很大，拖慢了 HTTPS 连接。

现在基本使用 OCSP，即在线证书状态协议 ( Online Certificate Status Protocol )，来查询证书的有效性，它的工作方式是向 CA 发送查询请求，让 CA 返回证书的有效状态。

不必像 CRL 方式客户端需要下载大大的列表，还要从列表查询，同时因为可以实时查询每一张证书的有效性，解决了 CRL 的实时性问题。

OCSP 需要向 CA 查询，因此也是要发生网络请求，而且还得看 CA 服务器的“脸色”，如果网络状态不好，或者 CA 服务器繁忙，也会导致客户端在校验证书这一环节的延时变大。

为了解决这一网络开销，就出现了 OCSP Stapling，其原理是：服务器向 CA 周期性的查询证书状态，获得一个带有时间戳和签名的响应结果并缓存。当客户端发起连接请求时，服务器会把这个「响应结果」在 TLS 握手过程中发给客户端。由于有签名的存在，服务器无法篡改，因此客户端就能得知证书是否已被吊销了，这样客户端就不需要再去查询。

###### 10.5 会话复用

TLS 握手的目的就是为了协商出会话密钥，也就是对称加密密钥，那如果我们把首次 TLS 握手协商的对称加密密钥缓存起来，待下次需要建立 HTTPS 连接时，直接「复用」这个密钥，就可以减少 TLS 握手的性能损耗了。这种方式就是会话复用 ( TLS session resumption )，会话复用分为两种，一种是 Session ID，另一种是 Session Ticket。

1. Session ID

Session ID 的工作原理是，客户端和服务器首次 TLS 握手连接后，双方会在内存缓存会话密钥，并用唯一的 Session ID 来标识，Session ID 和 会话密钥相当于 key-value 的关系。

当客户端再次连接时，hello 消息里会带上 Session ID，服务器收到后会在内存中找，如果找到就直接用该会话密钥恢复会话状态，跳过其余的过程，只用一个消息往返就可以建立安全通信，为了安全性，内存中的会话密钥会定期失效。

但是有两个问题：

- 服务器必须保持每一个客户端的会话密钥，随着客户端的增多，服务器的内存压力也会越大。
- 现在网站服务一般是由多台服务器通过负载均衡提供服务的，客户端再次连接不一定会命中上次访问过的服务器，于是还要走完整的 TLS 握手过程。

2. Session Ticket

为了解决 Session ID 的问题，就出现了 Session Ticket，服务器不再缓存每个客户端的会话密钥，而是把缓存的工作交给了客户端，类似于 HTTP 的 Cookie。

客户端与服务器首次建立连接时，服务器会加密「会话密钥」作为 Ticket 发给客户端，交给客户端缓存该 Ticket。

客户端再次连接服务器时，客户端会发送 Ticket，服务器解密后就可以获取上一次的会话密钥，然后验证有效期，如果没问题就可以恢复会话，开始通信了。

对于集群的服务器，要确保每一台服务器加密「会话密钥」的密钥是一致的，这样客户端携带 Ticket 访问任意一台服务器时，都能恢复会话。

Session ID 和 Session Ticket 都不具备前向安全性，因为一旦加密「会话密钥」的密钥被破解或者服务器泄漏「会话密钥」，前面劫持的通信密文都会被破解。同时应对重放攻击也很困难。避免重放攻击的方式就是需要对会话密钥设定一个合理的过期时间。

3. Pre-shared Key

前面的 Session ID 和 Session Ticket 方式都需要在 1 RTT 才能恢复会话。对于重连 TLS 1.3 只需要 0 RTT，原理和 Ticket 类似，只不过在重连时，客户端会把 Ticket 和 HTTP 请求一同发送给服务端，这种方式叫 Pre-shared Key。同样的，Pre-shared Key 也有重放攻击的危险。

##### 11. HTTP /2 好在哪？

###### 11.1 兼容 HTTP /1.1

第一点，HTTP /2 没有在 URI 里引入新的协议名，仍然用 http:// 表示明文协议，用 https://  表示加密协议，于是只需要浏览器和服务器在背后自动升级协议，这样可以让用户意识不到协议的升级，很好的实现了协议的平滑升级。

第二点，只在应用层做了改变，还是基于 TCP 协议传输，应用层方面为了保持功能上的兼容，HTTP/2 把 HTTP 分解成了「语义」和「语法」两个部分，「语义」层不做改动，与 HTTP/1.1 完全一致，比如请求方法、状态码、头字段等规则保留不变。

但是，HTTP/2 在「语法」层面做了很多改造，基本改变了 HTTP 报文的传输格式。

###### 11.2 头部压缩

HTTP 协议的报文是由「Header + Body」构成的，对于 Body 部分，HTTP /1.1 协议可以使用头字段「Content-Encoding」指定 Body 的压缩方式，比如用 gzip 压缩，这样可以节约带宽，但报文中的另外一部分 Header 没有针对的优化方法。

HTTP /1.1 报文中 Header 部分存在的问题：

- 含很多固定的字段，比如Cookie、User Agent、Accept 等，这些字段加起来也高达几百字节甚至上千字节，所以有必要压缩。
- 大量的请求和响应的报文里有很多字段值是重复的，这样会使大量贷款被这些冗余的数据占用了，所以有必要避免重复性。
- 字段是 ASCII 编码的，虽然易于人类观察，但效率低，所以有必要改成二进制编码。

HTTP /2 没使用常见的 gzip 压缩方式来压缩头部，而是开发了 HPACK 算法，HPACK 算法主要包含以下组成：

- 静态字典
- 动态字典
- Huffman 编码 ( 压缩算法 )

客户端和服务器两端都会建立维护这个字典，用长度较小的索引号表示重复的字符串，再用 Huffman 编码压缩数据，可达到 50%~90% 的高压缩率。

###### 11.3 二进制帧

HTTP /2 厉害的地方在于将 HTTP /1 的文本格式改成二进制格式传输数据，极大提高了 HTTP 传输效率，而且二进制数据使用位运算能高效解析。

HTTP/2 把响应报文划分成了两个帧（Frame），HEADERS（首部）和 DATA（消息负载） 是帧的类型，也就是说一条 HTTP 响应，划分成了两个帧来传输，并且采用二进制来编码。

帧头（Frame Header）很小，只有 9 个字节，帧开头的前 3 个字节表示帧数据（Frame Playload）的长度。

帧长度后面的一个字节是表示帧的类型，HTTP/2 总共定义了 10 种类型的帧，一般分为数据帧和控制帧两类。

帧类型后面的一个字节是标志位，可以保存 8 个标志位，用于携带简单的控制信息，比如：

- END_HEADERS 表示头数据结束标志，相当于 HTTP/1 里头后的空行 ( "\r\n" )
- END_STREAM 表示单方向数据发送结束，后续不会再有数据帧
- PRIORITY 表示流的优先级

帧头的最后 4 哥字节是流标识符 ( Stream ID )，但最高位被保留不用，只有 31 位可以使用，因此流标识符的最大值是 2^31，大约是 21 亿，它的作用是用来标识该 Frame 属于哪个 Stream，接收方可以根据这个信息从乱序的帧里找到相同 Stream ID 的帧，从而有序组装信息。

最后面就是帧数据了，它存放的是通过 HPACK 算法压缩过的 HTTP 头部和 body。

###### 11.4 并发传输

HTTP /2 通过 Stream 的设计，多个 Stream 复用一条 TCP 连接，达到并发的效果，解决了 HTTP /1.1 队头阻塞的问题，提高了 HTTP 传输的吞吐量。

- 1 个 TCP 连接包含一个或者多个 Stream，Stream 是 HTTP/2 并发的关键技术
- Stream 里可以包含 1 个或多个 Message，Message 对应 HTTP/1 中的请求或响应，由 HTTP 头部和包体构成
- Message 里包含一条或者多个 Frame，Frame 是 HTTP/2 最小单位，以二进制压缩格式存放 HTTP/1 中的内容 ( 头部和 body )

因此，HTTP 消息可以由多个 Frame 构成，以及 1 个 Frame 可以由多个 TCP 报文构成。

在 HTTP /2 连接上，不同 Stream 的帧是可以乱序发送的 ( 因此可以并发不同的 Stream )，因为每个帧的头部会携带 Stream ID 信息，所以接收端可以通过 Stream ID 有序组装成 HTTP 消息，而同一 Stream 内部的帧必须是严格有序的。

客户端和服务器双方都可以建立 Stream， Stream ID 也是有区别的，客户端建立的 Stream 必须是奇数号，而服务器建立的 Stream 必须是偶数号。

同一个连接中 的 Stream ID 不能复用，只能顺序递增，所以当 Stream ID 耗尽时，需要发一个控制帧 GOAWAY，用来关闭 TCP 连接。

在 Nginx 中，可以通过 http2_max_concurrent_streams 配置来设置 Stream 的上限，默认是 128 个。

HTTP /2 通过 Stream 实现的并发，比 HTTP /1.1 通过 TCP 连接实现并发要牛逼的多，因为当 HTTP /2 实现 100 个并发 Stream 时，只需要建立一次 TCP 连接，而 HTTP /1.1 需要建立 100 个 TCP 连接，每个 TCP 连接都要经过 TCP 握手、慢启动以及 TLS 握手过程，这些都是很耗时的。

HTTP /2 还可以对每个 Stream 设置不同优先级，帧头中的「标志位」可以设置优先级，比如客户端访问 HTML / CSS 和图片资源时，希望服务器先传递 HTML / CSS，再传图片，那么就可以通过设置 Stream 的优先级来实现，以此提高用户体验。

###### 11.5 服务器主动推送资源

客户端发起的请求，必须使用的是奇数号 Stream，服务器主动的推送，使用的是偶数号 Stream。服务器在推送资源时，会通过 PUSH_PROMISE 帧传输 HTTP 头部，并通过帧中的 Promised Stream ID 字段告知客户端，接下来会在哪个偶数号 Stream 中发送 body。

###### 11.6 HTTP /2 总结

第一点，对于常见的 HTTP 头部通过静态表和 Huffman 编码的方式，将体积压缩了近一半，而且针对后续的请求头部，还可以建立动态表，将体积压缩近 90%，大大提高了编码效率，同时节约了带宽资源。

不过，动态表并非可以无限增大， 因为动态表是会占用内存的，动态表越大，内存也越大，容易影响服务器总体的并发能力，因此服务器需要限制 HTTP /2 连接时长或者请求次数。

第二点，HTTP /2 实现了 Stream 并发，多个 Stream 只需复用 1 个 TCP 连接，节约了 TCP 和 TLS 握手时间，以及减少了 TCP 慢启动阶段对流量的影响。不同的 Stream ID 才可以并发，即时乱序发送帧也没问题，但是同一个 Stream 里的帧必须严格有序。

另外，可以根据资源的渲染顺序来设置 Stream 的优先级，从而提高用户体验。

第三点，服务器支持主动推送资源，大大提升了消息的传输性能，服务器推送资源时，会先发送 PUSH_PROMISE 帧，告诉客户端接下来在哪个 Stream 发送资源，然后用偶数号 Stream 发送资源给客户端。

HTTP/2 通过 Stream 的并发能力，解决了 HTTP/1 队头阻塞的问题，看似很完美了，但是 HTTP/2 还是存在“队头阻塞”的问题，只不过问题不是在 HTTP 这一层面，而是在 TCP 这一层。

HTTP/2 是基于 TCP 协议来传输数据的，TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区里的数据返回给 HTTP 应用，那么当「前 1 个字节数据」没有到达时，后收到的字节数据只能存放在内核缓冲区里，只有等到这 1 个字节数据到达时，HTTP/2 应用层才能从内核中拿到数据，这就是 HTTP /2 队头阻塞问题。

##### 12. HTTP /3 的优势

###### 12.1 HTTP /2 的问题

HTTP /2 的问题如下：

- 队头阻塞
- TCP 与 TLS 的握手时延
- 网络迁移需要重新连接

1. 队头阻塞

队头阻塞是HTTP /2 多个请求是跑在一个 TCP 连接中的，那么当 TCP 丢包时，整个 TCP 都要等待重传，那么就会阻塞该 TCP 连接中的所有请求。

2. TCP 与 TLS 的握手时延

因为 TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且有序的，如果序列号较低的 TCP 段在网络传输中丢失了，即使较高的 TCP 段已经被接受了，应用层也无法从内核中读取该部分数据，从 HTTP 的视角看，就是请求被阻塞了。

发送 HTTP 请求时，需要经过 TCP 三次握手和 TLS 四次握手 ( TLS 1.2 ) 的过程，因此共需要 3  个 RTT 的时延才能发出请求数据。而且 TCP 由于具有「拥塞控制」的特性，所以刚建立连接的 TCP 会有个「慢启动」的过程，它会对 TCP 连接产生"减速"效果。

3. 网络迁移需要重新连接

一个 TCP 连接是由四元组 ( 源 IP 地址、源端口、目标 IP 地址、目标端口 ) 确定的，这意味着如果 IP 地址或者端口变动了，会导致 TCP 和 TLS 重新握手，这不利于移动设备切换网络的场景，比如 4G 切换成 WIFI。

###### 12.2 QUIC 协议的特点

UDP 是一个简单、不可靠的传输协议，而且是 UDP 包之间是无序的，也没有依赖关系。而且，UDP 是不需要连接的，也就不需要握手和挥手的过程，所以天然的就比 TCP 快。HTTP /3 不仅仅是简单将传输协议换成了 UDP，还基于 UDP 协议在「应用层」实现了 QUIC 协议，它具有类似 TCP 的连接管理、拥塞窗口、流量控制的网络特性，相当于将不可靠传输的 UDP协议变成可靠的，所以不用担心数据包丢失的问题。

1. 无队头阻塞

QUIC 协议也有类似 HTTP /2 Stream 与多路复用的概念，也是可以在同一条连接上并发传输多个 Stream，Stream 可以认为是一条 HTTP 请求。

由于 QUIC 使用的传输协议是 UDP，UDP 不关心数据包的顺序，如果数据包丢失，UDP 也不关心。不过 QUIC 协议会保证数据包的可靠性，每个数据包都有一个序号唯一标识，当某个流中的一个数据包丢失了，即使该流的其他数据包到达了，数据也无法被 HTTP /3 读取，直到 QUIC 重传丢失的报文，数据才会交给 HTTP /3。而其他流的数据报文只要被完整接收，HTTP/3 就可以读取到数据。这与 HTTP/2 不同，HTTP/2 只要某个流中的数据包丢失了，其他流也会因此受影响。

所以，QUIC 连接上的多个 Stream 之间并没有依赖，都是独立的，某个流发生丢包了，只会影响该流，其他流不受影响。

2. 更快的连接建立

对于 HTTP /1 和 HTTP /2 协议，TCP 和 TLS 是分层的，分别属于内核实现的传输层、openssl 库实现的表示层，因此它们难以合并在一起，需要分批次来握手，先 TCP 握手，再 TLS 握手。

HTTP /3 在传输数据前虽然需要 QUIC 协议握手，这个握手过程只需要 1 RTT，握手的目的是为确认双方的「连接 ID」，连接迁移就是基于连接 ID 实现的。但是 HTTP  /3 的 QUIC 协议并不是与 TLS 分层，而是 QUIC 内部包含了 TLS，它在自己的帧会携带 TLS 里的“记录”，再加上 QUIC 使用的是 TLS 1.3，因此仅需要 1 个 RTT 就可以「同时」完成建立连接与密钥协商，甚至在第二次连接的时候，应用数据包可以和 QUIC 握手信息 ( 连接信息 + TLS 信息 ) 一起发送，可以做到 0 RTT 的效果。

3. 连接迁移

QUIC 协议没有用四元组的方式来“绑定”连接，而是通过连接 ID 来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标识自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息 ( 比如连接 ID，TLS 密钥等 )，就可以无缝地复用原连接，消除重连的成本，没有丝毫卡顿感，达到了连接迁移的功能。

###### 12.3 HTTP /3 协议

HTTP /3 同 HTTP /2 一样采用二进制帧的结构，不同的地方在于 HTTP /2 的二进制帧里需要定义 Stream，而 HTTP /3 自身不需要再定义 Stream，直接使用 QUIC 里的 Stream，于是 HTTP /3 的帧的结构也变简单了。

HTTP /3 的帧头只有两个字段：类型和长度。根据帧类型的不同，大体上分为数据帧和控制帧两大类，HEADERS 帧 ( HTTP 头部 ) 和 DATA 帧 ( HTTP body ) 属于数据帧。HTTP /3 在头部压缩算法这一方面也做了升级，升级成了 QPACK。与 HTTP /2 中的 HPACK 编码方式相似，HTTP /3 中的 QPACK 也采用了静态表、动态表及 Huffman 编码。

#### TCP 

##### 1. TCP 三次握手与四次挥手

###### 1.1 TCP 基本认识

首先看一下 TCP 的头部格式，

![TCP 头部格式。图源小林Coding](https://github.com/ZonzeeLi/Interview/blob/master/picture/TCP%E5%A4%B4%E9%83%A8%E6%A0%BC%E5%BC%8F.png)

序列号：在建立连接时由计算机生成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。用来解决网络包乱序问题。

确认应答号：指下一次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。用来解决丢包的问题。

控制位：

- ACK：该位为 1 时，「确认应答」的字段变为有效，TCP 规定除了最初建立连接时的 SYN 包之外该位必须设置为 1 。
- RST：该位为 1 时，表示 TCP 连接中出现异常必须强制断开连接。
- SYN：该位为 1 时，标识希望建立连接，并在其「序列号」的字段进行序列号初始值的设定。
- FIN：该位为 1 时，标识今后不再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 FIN 位为 1 的 TCP 段。

IP 层是不可靠的，它不保证网络包的交付、不保证网络包的按序交付、也不保证网络包中的数据的完整性。如果需要保障网络数据包的可靠性，那么就需要由上层 ( 传输层 ) 的 TCP 协议来负责。因为 TCP 是一个工作在传输层的可靠数据传输的服务，它能确保接收端接受的网络包是无损坏、无间隔、非冗余和按序的。

TCP 是面向连接的、可靠的、基于字节流的传输层通信协议。

- 面向连接：一定是「一对一」才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；
- 可靠的：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；
- 字节流：用户消息通过 TCP 协议传输时，消息可能会被操作系统「分组」成多个的 TCP 报文，如果接收方的程序如果不知道「消息的边界」，是无法读出一个有效的用户消息的。并且 TCP 报文是「有序的」，当「前一个」TCP 报文没有收到的时候，即使它先收到了后面的 TCP 报文，那么也不能扔给应用层去处理，同时对「重复」的 TCP 报文会自动丢弃。

而连接的定义为，用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括Socket、序列号和窗口大小称为连接。

所以建立一个 TCP 连接是需要客户端与服务器端达成上述三个信息的共识。

- Socket：由 IP 地址和端口号组成
- 序列号：用来解决乱序问题等
- 窗口大小：用来做流量控制

TCP 四元组可以唯一的确定一个连接，四元组包括源地址、源端口、目的地址、目的端口。

源地址和目的地址的字段 ( 32 位 ) 是在 IP 头部中，作用是通过 IP 协议 发送报文给对方主机。

源端口和目的端口的字段 ( 16 位 ) 是在 TCP 头部中，作用是告诉 TCP 协议应该把报文发给哪个进程。

有一个 IP 的服务器监听了一个端口，它的 TCP 的最大连接数是多少？

服务器通常固定在某个本地端口上监听，等待客户端的连接请求。因此，客户端 IP 和 端口是可变的，其理论值计算位，最大 TCP 连接数 = 客户端的 IP 数 × 客户端的端口数。

对 IPv4，客户端的 IP 数最多为 2 的 32 次方，客户端的端口数最多为 2 的 16 次方，也就是服务端单机最大 TCP 连接数，约为 2 的 48 次方。但是服务端最大并发 TCP 连接数远不能达到理论上限，会受以下因素影响：

- 文件描述符限制。每个 TCP 连接都是一个文件，如果文件描述符被沾满了，会发生 too many open files。Linux 对可打开的文件描述符数量分别作了三个方面的限制：
	- 系统级：当前系统可打开的最大数量，通过 cat /proc/sys/fs/file-max 查看；
	- 用户级：指定用户可打开的最大数量，通过 cat /etc/security/limits.conf 查看；
	- 进程级：单个进程可打开的最大数量，通过 cat /proc/sys/fs/nr_open 查看；
- 内存限制。每个 TCP 连接都要占用一定的内存，操作系统的内存是有限的，如果内存资源被占满后，会发生 OOM。

UDP 和 TCP 有什么区别呢？分别的应用场景是？

UDP 不提供复杂的控制机制，利用 IP 提供面向「无连接」的通信服务。而且 UDP 的协议非常简介，头部只有 8 个字节 ( 64 位 )：

- 目标和源端口：主要是告诉 UDP 协议应该把报文发送给哪个进程。
- 包长度：该字段保存了 UDP 首部的长度跟数据的长度之和。
- 校验和：校验和是为了提供可靠的 UDP 首部和数据而设计，防止收到在网络传输中受损的 UDP 包。

TCP 和 UDP 区别：

1. 连接

- TCP 是面向连接的传输层协议，传输数据前先要建立连接。
- UDP 是不需要连接，即刻传输数据。

2. 服务对象

- TCP 是一对一的两点服务，即一条连接只有两个端点。
- UDP 支持一对一、一对多、多对多的交互通信。

3. 可靠性

- TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按需到达。
- UDP 是尽最大努力交付，不保证可靠交付数据。

4. 拥塞控制、流量控制

- TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。
- UDP 则没有，即使网络非常拥堵，也不会影响 UDP 的发送速率。

5. 首部开销

- TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 20 个字节，如果使用了「选项」字段则会变长的。
- UDP 首部只有 8 个字节，并且是固定不变的，开销很小。

6. 传输方式

- TCP 是流式传输，没有边界，但保证顺序和可靠。
- UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。

7. 分片不同

- TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。
- UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。

TCP 和 UDP 应用场景：

由于 TCP 是面向连接，能保证数据的可靠性交付，因此经常用于：

- FTP 文件传输
- HTTP / HTTPS

由于 UDP 面向无连接，它可以随时发送数据，再加上 UDP 本身的处理既简单又高效，因此经常用于：

- 包总量较少的通信，如 DNS、SNMP 等
- 视频、音频等多媒体通信
- 广播通信

为什么 UDP 头部没有「首部长度」字段，而 TCP 头部有「首部长度」字段呢？

原因是 TCP 有可变长的「选项」字段，而 UDP 头部长度则是不会变化的，无需多一个字段去记录 UDP 的首部长度。

为什么 UDP 头部有「包长度」字段，而 TCP 头部则没有「包长度」字段呢？

TCP 的负载数据长度计算为：TCP 的数据长度 = IP 总长度 - IP 首部长度 - TCP 首部长度

其中 IP 总长度和 IP 首部长度，在 IP 首部格式是已知的。TCP 首部长度，则是在 TCP 首部格式已知的，所以可以计算出 TCP 数据的长度。但其实 UDP 也同样可以计算，因为为了网络设备硬件设计和处理方便，首部长度需要是 4 字节的整数倍。如果去掉该字段的话，那首部长度就不是 4 字节的整数倍了。

###### 1.2 TCP 连接建立

TCP 三次握手的过程如下图：

![TCP 三次握手。图源小林Coding]()

- 一开始，客户端和服务端都处于 CLOSED 状态。先是服务端主动监听某个端口，处于 LISTEN 状态。
- 三次握手的第一个报文 SYN 报文：客户端会随机初始化序号 ( client_isn )，将此序号置于 TCP 首部的「序列号」字段中，同时把 SYN 标志位置为 1，表示 SYN 报文。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 SYN-SENT 状态。
- 三次握手的第二个报文 SYN + ACK 报文：服务端收到客户端的 SYN 报文后，首先服务端也随机初始化自己的序号 ( server_isn )，将此序号填入 TCP 的首部的「序列号」字段中，其次把 TCP 首部的「确认应答号」字段填入 client_isn + 1，接着把 SYN 和 ACK 标志位置为 1，最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 SYN-RCVD 状态。
- 三次握手的第三个报文 ACK 报文：客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 ACK 标志位置为 1，其次「确认应答号」字段填入 server_isn + 1，最后把报文发送给服务端，这一次报文可以携带客户端到服务器的数据，之后客户端处于 ESTABLISHED 状态。
- 服务器收到客户端的应答报文后，也进入 ESTABLISHED 状态。

比较常问的则是前两次握手是不可以携带数据的，第三次握手是可以携带数据的。一旦完成握手，双方都处于 ESTABLISHED 状态，此时连接就建立完成，可以相互发送数据了。

在 Linux 中查看 TCP 的状态通过 netstat -napt 命令查看。

为什么是三次握手？

因为三次握手才能保证双方具有接收和发送的能力。连接是用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括 Socket、序列号和窗口大小称为连接。所以三次握手才可以初始化 Socket、序列号和窗口大小并建立 TCP 连接。以三个方面分析三次握手的原因：

- 三次握手才可以阻止重复历史连接的初始化 ( 主要原因 )
- 三次握手才可以同步双方的初始序列号
- 三次握手才可以避免资源浪费

1. 避免历史连接

为了防止旧的重复连接初始化造成混乱。客户端连续发送多次 SYN 建立连接的报文，在网络拥堵的情况下：

- 一个「旧 SYN 报文」比「最新的 SYN 」 报文早到达了服务端
- 那么此时服务端会回一个 SYN + ACK 报文给客户端
- 客户端收到后可以根据自身的上下文，判断这是一个历史连接 ( 序列号过期或超时 )，那么客户端就会发送 RST 报文给服务端，表示中止这一次连接。

如果是两次握手连接，就无法组织历史连接，因为在两次握手的情况下，「被动发起方」没有中间状态给「主动发起方」来阻止历史连接，导致「被动发起方」可能建立一个历史连接，造成资源浪费。要解决这种现象，最好就是在「被动发起方」发送数据前，也就是建立连接之前，要阻止掉历史连接，这样就不会造成资源浪费，而要实现这个功能，就需要三次握手。

2. 同步双方初始序列号

TCP 协议的通信双方，都必须维护一个「序列号」，序列号是可靠传输的一个关键因素，它的作用是：

- 接收方可以去除重复的数据
- 接收方可以根据数据包的序列号按序接收
- 可以标识发送出去的数据包中，哪些是已经被对方收到的 ( 通过 ACK 报文中的序列号知道 )

当客户端发送携带「初始序列号」的 SYN 报文的时候，需要服务端回一个 ACK 应答报文，表示客户端的 SYN 报文已被服务端成功接收，那当服务端发送「初始序列号」给客户端的时候，依然也要得到客户端的应答回应，这样一来一回，才能确保双方的初始序列号能被可靠的同步。两次握手只保证了一方的初始序列号被对方接收，没办法保证双方的都被确认。

3. 避免资源浪费

如果客户端的 SYN 阻塞了，重复发送多次 SYN 报文，那么服务器在收到请求后就会建立多个冗余的无效链接，造成不必要的资源浪费。

为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？

- 为了防止历史报文被下一个相同四元组的连接接收 ( 主要方面 )
- 为了安全性，防止黑客伪造的相同序列号的 TCP 报文被对方接收

假设每次建立连接，客户端和服务端的初始化序列号都是从 0 开始，客户端和服务端建立一个 TCP 连接，在客户端发送数据包被网络阻塞了，而此时服务端的进程重启了，于是就会发送 RST 报文来断开连接。紧接着，客户端又与服务端建立了与上一个连接相同四元组的连接，在新连接建立完成，上一个连接中被网络阻塞的数据包正好抵达了服务端，刚好该数据包的序列号正好是在服务端的接收窗口，所以该数据包会被服务端正常接收，造成混乱。所以如果每次建立连接，客户端和服务端的初始化序列号都是一样的话，很容易出现历史报文被下一个相同四元组的连接接收的问题。

为什么 TCP 层还需要 MSS 呢？

- MTU：一个网络包的最大长度，以太网中一般为 1500 字节。
- MSS：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度。

当 IP 层有一个超过 MTU 大小的数据 ( TCP 头部 + TCP 数据 ) 要发送，那么 IP 层就要进行分片，把数据分片成若干份，由目标主机的 IP 层来进行重新组装，再交给上一层 TCP 传输层。但如果有一个 IP 分片丢失，整个 IP 报文的所有分片都要重传，因为 IP 没有超时重传机制，它由传输层的 TCP 来负责超时和重传。所以如果整个 TCP 报文也要交给 IP 层进行超时全部重传是非常没有效率的。

所以，为了达到最佳的传输效能，TCP 协议在建立连接的时候通常要协商双方的 MSS 值，当 TCP 层发现数据超过 MSS 时，就会先进行分片，由它形成的 IP 包长度就不会大于 MTU，自然不用 IP 分片了。经过 TCP 层分片后，如果一个 TCP 分片丢失后，进行重发时也是以 MSS 为单位，而不用重传所有的分片，大大增加了重传的效率。

三次握手丢失，会发生什么？

1. 第一次握手丢失

当客户端想和服务端建立 TCP 连接的时候，首先第一个发的是 SYN 报文，然后进入到 SYN_SENT 状态，如果客户端迟迟收不到服务端的 SYN-ACK ( 第二次握手 )，就会触发超时重传机制，重传 SYN 报文。不同版本的操作系统可能超时时间不同，这个是写死在内核里的，而且对于重发次数来讲，在 Linux 里，客户端的 SYN 报文最大重传次数由 tcp_syn_retries 内核参数控制，这个参数是可以自定的，一般为 5，通常每次超时时间是上一次的 2 倍，当第 5 次超时重传，如果服务端仍然没有回应 ACK，客户端就不再发送 SYN 包，然后断开 TCP 连接。

2. 第二次握手丢失

当服务端收到的第一次握手后，回 SYN-ACK 给客户端，此时服务端进入 SYN_RCVD 状态。如果第二次握手客户端迟迟没有收到，那么客户端会认为自己的 SYN 报文丢失了，这样客户端会触发超时重传机制，重传 SYN 报文。而且因为客户端如果收到第二次握手的报文会发送 ACK 给服务端，但如果第二次握手报文丢失，服务端收不到第三次握手，会触发超时重传机制，重传 SYN-ACK 报文。在 Linux 下，SYN-ACK 报文的最大重传次数由 tcp_synack_retries内核参数决定，默认值是 5。

3. 第三次握手丢失

客户端收到服务端的 SYN-ACK 后，会回一个 ACK 报文，此时客户端进入 ESTABLISH 状态。如果第三次握手丢失了，服务端收不到确认报文，就会触发超时重传机制。

注意 ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文。

SYN 攻击

TCP 连接需要三次握手，假设攻击者短时间内伪造不同的 IP 地址的 SYN 报文，服务端没收到一个 SYN 报文，就进入 SYN_RCVD 状态，但服务端发送出去的 ACK + SYN 报文，无法得到未知 IP 主机的 ACK 应答，久而久之占满服务端的半连接队列，使得服务器不能为正常用户服务。

避免 SYN 攻击方式一：

通过修改 Linux 内核参数，控制队列大小和当队列满时应做什么处理。当网卡接收数据包的速度大于内核处理的速度时，会有一个队列保存这些数据包，控制这些队列的最大值为 net.core.netdev_max_backlog，SYN_RCVD 状态连接的最大个数为 net.ipv4.tcp_max_syn_backlog，当队列满，对新的 SYN 直接回 RST，丢弃连接，net.ipv4.tcp_abort_on_overflow。

避免 SYN 攻击方式二：

Linux 内核的 SYN 队列 ( 半连接队列 ) 和 Accpet 队列 ( 全连接队列 ) 的工作流程如下：

- 当服务端接收到客户端的 SYN 报文时，会将其加入到内核的「 SYN 队列」
- 接着发送 SYN + ACK 给客户端，等待客户端回应 ACK 报文
- 服务端接收到 ACK 报文后，从「 SYN 队列」移除放入到「 Accept 队列」
- 应用通过调用 accpet() socket 接口，从「 Accept 队列」取出连接

如果应用程序过慢。就会导致「 Accept 队列」被占满。如果受到了 SYN 攻击：

- 如果不断受到 SYN 攻击，就会导致 SYN 队列 ( 半连接队列 ) 被占满，从而导致无法再建立新的连接。tcp_syncookies 的方式可以应对 SYN 攻击的方法：net.ipv4.tcp_syncookies = 1
- 当「 SYN 队列」满之后，后续服务器收到 SYN 包，不进入「 SYN 队列」
- 计算出一个 cookie 值，再以 SYN + ACK 中的「序列号」返回客户端
- 服务端接收到客户端的应答报文时，服务器会检查这个 ACK 包的合法性。如果合法，直接放入到「 Accept 队列」
- 最后应用通过调用 accpet () socket 接口，从「 Accept 队列」取出的连接

###### 1.3 TCP 连接断开

TCP 断开连接是通过四次挥手的方式，双方都可以主动断开连接，断开连接后主机中的「资源」将被释放。

![TCP 四次挥手。图源小林Coding]()

- 客户端打算关闭连接，此时会发送一个 TCP 首部 FIN 标志位置为 1 的报文，即 FIN 报文，之后客户端进入 FIN_WAIT_1 状态
- 服务端收到该报文后，就向客户端发送 ACK 应答报文，接着服务端进入 CLOSED_WAIT 状态
- 客户端收到服务端的 ACK 应答报文后，之后进入 FIN_WAIT_2 状态
- 等待服务端处理完数据后，也向客户端发送 FIN 报文，之后服务端进入 LAST_ACK 状态
- 客户端收到服务端的 FIN 报文后，回一个 ACK 应答报文，之后进入 TIME_WAIT 状态
- 服务器收到了 ACK 应答报文后，就进入了 CLOSED 状态，至此服务端已经完成连接的关闭
- 客户端在经过了 2MSL 一段时间后，自动进入 CLOSED 状态，至此客户端也完成连接的关闭。

每个方向都需要一个 FIN 和一个 ACK，需要注意只有主动关闭来连接的才有 TIME_WAIT 状态。

#### WebSocket

### Go语言

#### 函数 & 关键字

##### 1. make()、new()、var的区别？

&emsp;&emsp;new的特点

- 分配内存。内存里存的值是对应类型的零值。
- 只有一个参数。参数是分配的内存空间所存储的数据类型，Go语言里的任何类型都可以是new的参数，比如int， 数组，结构体，甚至函数类型都可以。
- 返回的是指针。

注: new在项目中很少见，可以被多种方法替代。

&emsp;&emsp;make的特点

- 分配和初始化内存。
- 只能用于slice, map和chan这3个类型，不能用于其它类型。
- 如果是用于slice类型，make函数的第2个参数表示slice的长度，这个参数必须给值。
- 返回的是原始类型，也就是slice, map和chan，不是返回指向slice, map和chan的指针。

&emsp;&emsp;为什么针对slice, map和chan类型专门定义一个make函数？这是因为slice, map和chan的底层结构上要求在使用slice，map和chan的时候必须初始化，如果不初始化，那slice，map和chan的值就是零值，也就是nil。我们知道：map如果是nil，是不能往map插入元素的，插入元素会引发panic。chan如果是nil，往chan发送数据或者从chan接收数据会引发panic。slice会有点特殊，理论上slice如果是nil，也是没法用的。但是append函数处理了nil slice的情况，可以调用append函数对nil slice做扩容。但是我们使用slice，总是会希望可以自定义长度或者容量，这个时候就需要用到make。

&emsp;&emsp;new来创建slice, map和chan的都是nil，并没有什么用。

&emsp;&emsp;var的特点

- 声明一个type类型的变量，分配内存空间给type类型的零值。
- 声明一个type类型的指针变量，不会分配内存空间，零值为nil。
- 声明一个type类型的变量，并赋值。

#### 切片

##### 1. 切片的扩容策略？

&emsp;&emsp;切片在扩容时会进行内存对齐，这个和内存分配策略相关。进行内存对齐之后，新 slice 的容量是要 大于等于老 slice 容量的 2倍或者1.25倍，当原 slice 容量小于 1024 的时候，新 slice 容量变成原来的 2 倍；原 slice 容量超过 1024，新 slice 容量变成原来的1.25倍。

### 数据库知识

#### MySQL

#### Redis

#### NoSQL

##### 1. NoSQL的优缺点？

&emsp;优点

- 高可扩展性
- 分布式计算
- 低成本
- 架构的灵活性，半结构化数据
- 没有复杂的关系

&emsp;缺点

- 没有标准化
- 有限的查询功能（到目前为止）
- 最终一致是不直观的程序

### 分布式

##### 1. 分布式计算的优缺点有哪些？

&emsp;优点

- 可靠性（容错）：分布式计算系统中的一个重要的优点是可靠性。一台服务器的系统崩溃并不影响到其余的服务器。
- 可扩展性：在分布式计算系统可以根据需要增加更多的机器。
- 资源共享：共享数据是必不可少的应用，如银行，预订系统。
- 灵活性：由于该系统是非常灵活的，它很容易安装，实施和调试新的服务。
- 更快的速度：分布式计算系统可以有多台计算机的计算能力，使得它比其他系统有更快的处理速度。
- 开放系统：由于它是开放的系统，本地或者远程都可以访问到该服务。
- 更高的性能：相较于集中式计算机网络集群可以提供更高的性能（及更好的性价比）。

&emsp;缺点

- 故障排除：故障排除和诊断问题。
- 软件：更少的软件支持是分布式计算系统的主要缺点。
- 网络：网络基础设施的问题，包括：传输问题，高负载，信息丢失等。
- 安全性：开放系统的特性让分布式计算系统存在着数据的安全性和共享的风险等问题。

### 工具

#### Docker

#### Kubernetes

#### Git
