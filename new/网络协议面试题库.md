# 网络协议面试题库

## 场景

### 介绍一下 OSI 七层协议，各层协议都有哪些？

按照顺序依次是，应用层、表示层、会话层、传输层、网络层、数据链路层、物理层

应用层的协议有 HTTP、HTTPS，传输层有 TCP、UDP，网络层有 IP、ICMP。

### IP 协议和 TCP 协议属于哪一层？

IP 是网络层，TCP 是传输层。

### 输入网址后，期间发生了什么？

1. 输入网址后，会对 URL 进行解析，得到要发往的 Web 服务器、文件路径、请求参数、协议等内容。
2. 然后通过域名解析 DNS，得到要访问服务器的 IP 地址。先查看本地系统缓存的 host 文件中是否有记录，没有就会去域名服务器获取 IP 地址。
3. 接着由于需要 TCP 建立三次握手连接，所以要生成 TCP 的报文信息，填入源端口和目的端口，在建立连接之后，就可以通过 TCP 传入数据，如果长度超过了 MSS，会进行分片。
4. 接着到网络层，会填入源 IP 地址和目的 IP 地址，以及协议号等 IP 报文信息，封装成网络包发送。
5. 然后到数据链路层，会填入源 MAC 地址和目标 MAC 地址，如果有缓存保存了目标 MAC 地址，则直接使用，如果不知道目标 MAC 地址，会通过地址解析协议 ARP，以广播的形式，获取路由的 MAC 地址。
6. 接着会通过网卡将数据包转换成电信号发送出去。
7. 通过交换机到达路由器，然后路由器会通过路由表转发到目的服务器，然后获取响应后返回。

### DNS 是如何解析的？

以`www.server.com`为例，DNS 会先查询本地域名服务器缓存的 host 文件中是否有目标的 IP 地址，如果没有的话，会请求根域名服务器`.`，根域名服务器会返回顶级域名服务器`.com`，然后请求顶级域名服务器`.com`，顶级域名服务器会返回权威 DNS 服务器的地址，然后权威域名服务器会返回`www.server.com`的 IP 地址。

### 输入域名如何知道端口的？

服务端 http 的默认端口是 80，https 的默认端口是 443，如果服务端自己写了服务 bind 端口则使用具体的的端口。

### 如果浏览器没有显示页面有哪些原因？

首先确定下是不是客户端的网络问题，排查下是不是断网、没有网卡等问题，其次检查下是否填写正确访问到了正确的服务端地址，然后可以在命令行尝试`ping`一下服务端，确定可以建立正常的连接，如果连接出现问题则可以抓包分析究竟是哪一包出现了问题，然后可以通过返回的 http 状态码进行分析，比如 404 not found，可能是服务端下线或者访问地址输入错误，如果是 500 ，可能是服务端繁忙、崩溃等问题。最后看是否是前端渲染的代码出现 bug 问题。

### 客户端 TCP 连接一个不存在的 IP 地址的服务端会发生什么？

由于目标地址不存在，网络包在路由之间跳转，超过生命周期或者跳转次数之后，这个包就会丢弃，路由会通过 ICMP 返回一个不可达序号报文。

### 客户端 TCP 连接一个 IP 地址存在但是端口不存在报文会发生什么？

由于 IP 地址存在，网络包可以到达，但是端口不存在，说明没有 listen()，这时候会回复一个 RST 断开连接报文。

### 客户端 UDP 发送一个 IP 地址存在但是端口不存在报文会发生什么？

服务端会通过 ICMP 返回一个端口不存在序号报文。

### 四层和七层负载均衡的区别

四层负载均衡主要是在传输层中实现，不关心报文中的内容，通过目的地址和端口，再选择一个内部服务器，会对目标地址进行修改。而七层负载均衡是在应用层实现，会解析报文，针对报文中的内容，比如 URL 或者 Cookie 中的信息做出负载均衡。

## HTTP 

### HTTP 报文格式？怎么分割的？

HTTP 的报文分成请求报文和响应报文两种：

请求报文包含请求行、请求头、请求体，其中请求行是请求的 method（GET、POST等），以及请求的 HTTP 版本和路径，请求头中是一些属性值和 tag 标签，比如 Content-Lenth、Connection 等字段的属性值，请求体是具体的请求 body 数据。

响应报文包含响应状态、响应头、响应体，其中响应状态是响应的 HTTP 版本和状态码信息，响应头中也是一些 Content-Lenth、Connection 等字段的属性值和 tag 标签，响应体是返回的具体 body 数据。

分割是通过换行符来进行分割的，如果数据中包含换行符要进行转义。

### HTTP 有什么方法

常用的是 GET 获取资源、POST 带着请求数据访问服务端、DELETE 删除资源、PUT 带着更新数据访问服务端。

### 分析一下哪些 HTTP 方法是安全或者幂等的？

以 GET、POST、DELETE、PUT 为例，只有 GET 是幂等的，因为获取资源，并不会提交更新的操作，多次操作的结果都是一样的，而另外三种方法会对资源进行修改，不是幂等的。

### GET 和 POST 请求的区别？追问：GET 请求一定是安全且幂等的吗？

GET 是请求从服务端获取资源，POST 是带着请求数据去更改服务端的资源，但这不一定说 GET 请求就一定是幂等的，具体要看服务端的 handler 实现逻辑，服务端可以将 GET 方法做成和 POST 一样可以修改资源的逻辑。

### HTTP 有什么状态码？

HTTP 的状态码有五大类，分别是 1、2、3、4、5 开头：

- 1xx 开头的状态码，表示处理的中间状态，后续还有操作；
- 2xx 开头的状态码，表示请求成功，比如 200 就是常见的 请求成功，204 表示成功但是没有响应数据，206 表示成功但是响应并不是完整的资源，只是分块的一部分；
- 3xx 开头的状态码，表示服务端重定向，比如 301 是永久重定向，服务端的资源已经更换地址，302 是临时重定向，服务端的资源需要临时访问一个其他地址获取，304 是服务端的资源未修改，可以使用客户端本身的缓存资源来使用；
- 4xx 开头的状态码，表示的错误状态码，服务端处理错误，比如 404 就是 not found，表示服务端下线或者访问的地址不存在，400 表示的是请求的报文格式或内容有错，403 表示的是禁止客户端访问，一般像鉴权失败的时候返回；
- 5xx 开头的状态码，表示的是服务端出错了，具体的错误由状态码决定，比如 500 表示的一般是服务端处理不过来、崩溃、自定义错误信息返回，501 表示的是服务端暂不支持此功能，502 表示的是 bad gateway，一般是网关代理出现了问题，像 nginx 代理出错，503 表示的是服务器繁忙，无法响应。

### 重定向是哪一类状态码？临时重定向和永久重定向有什么区别？

重定向是 3xx 开头的状态码，301 表示的是永久重定向，服务端的资源已经更换了地址，客户端下一次要请求新的 url，302 表示的是临时重定向，服务端的资源暂时需要访问一个其他地址获取。

### HTTP 1.1 和 2.0 的区别？

- HTTP 2.0 进行了头部压缩，如果多个请求的头部是相同的，则会删除相同的部分，通过 HPACK 算法，将头部信息存在客户端和服务端的一张表上，只需要携带索引号即可；
- HTTP 2.0 更改报文格式为二进制格式，以帧的形式传输；
- HTTP 2.0 可以并发传输，1.1 必须是处理完一条 TCP 连接响应结束后，才能处理下一条，而 HTTP 2.0 引入了 Stream 的概念，多个 Stream 可以复用一个 TCP 连接，而且可以乱序，但是由于 TCP 的滑动窗口读取，依然会存在队头阻塞问题；
- HTTP 2.0 可以支持服务端主动推送资源。

### HTTP 2.0 和 3.0 的区别？

- HTTP 3.0 的传输层改成 UDP 协议，解决了 HTTP 2.0 由于 TCP 的原因存在的队头阻塞问题，基于 UDP 的 QUIC 协议为每个 Stream 都分配了滑动窗口，如果某个 Stream 包丢失了，只会阻塞这个 Stream，不会影响其他 Stream；
- HTTP 3.0 可以更快的建立连接，HTTP 2.0 使用 TCP 协议，需要三次握手，至少一个 RTT 可以建立连接，如果有 TLS，则有需要 2 个 RTT，就算是 TLS v1.3版本，在 TCP 第三次握手携带 TLS 第一次握手的信息也至少需要 2 个 RTT，而 HTTP 3.0 使用的 QUIC 协议，只需要连接 ID，1 个 RTT，而且 QUIC 协议中包含了 TLS，而且使用的是 TLS v1.3 版本，所以整体只需要 1 个 RTT，如果是复用重新连接，可以做到 0 RTT；
- HTTP 3.0 如果网络切换会更稳定，HTTP 2.0 使用 TCP 协议，连接是通过四元组确定的，如果网络发生切换，IP 发生改变，那么就需要重新连接，现象就是会有卡顿，而 HTTP 3.0 使用 QUIC 协议，使用连接 ID 来确定，所以只要保存连接 ID，即使切换网络，也不会对原先的连接有影响。

### HTTP 用户后续的操作，服务端如何知道属于同一个用户？追问：如果服务端是一个集群机器？

用户带着用户信息，比如账号密码，请求服务端，服务端将用户的个人信息保存成 session id 存到 cookie 中返回给客户端，客户端下一次在 cookie 中写入 session id，服务端取出后进行比对就知道是否是之前的用户。

如果是集群，可以将 session id 保存在 redis 中，通过请求一台（或者 redis 集群，集群同步交给 redis 的数据一致性实现）获取session id。也可以使用 JWT 的方式，服务端不保存 session 信息，JWT 是将 token 保存在客户端，服务端这边拿到 token 后做本地校验即可。

### 如果禁用 Cookie，怎么实现 Session？

可以将 Session 作为 Param 放在 url query 中，或者放在 body 的字段当中。

### Cookie 和 Session 的区别？

- Cookie 是存储在客户端浏览器中，Session 是存在服务端；
- 由于 Cookie 是存放在客户端浏览器，Session 是存放在服务端，所以 Cookie 的安全性较低；
- 由于 Cookie 是存放在客户端浏览器中，Session 是存放在服务端，所以 Cookie 的大小要比 Session 小很多；
- 使用场景不同，Cookie 可以用来保存用户的一些信息，比如在浏览器关闭页面后重新打开，不需要重复登录，而 Session 可以基于 Cookie 实现，更多用来会话跟踪、描述用户状态。

### 简述 JWT 的原理和校验机制

JWT 由三部分组成，分别是 header、payload、signature，header 是使用的签名算法，payload 是用户的信息，signature 是通过签名算法对 payload 进行的加密计算。JWT 不像 Session 一样，不保存在服务端，只保存在客户端，

客户端首次访问服务端，服务端会根据用户信息生成一个 JWT，生成的规则是用服务端的密钥，通过签名算法加密计算，返回给客户端，客户端下次带着 JWT 来访问，服务端通过密钥对 header 和 payload 再次通过签名算法加密计算，比对生成的 signature 是否一致，一致则认证通过。

### 什么是跨域？什么情况下会发生跨域请求？

当对一个域名进行请求，结果调用了另一个域名、协议、端口任意一个不相同的请求，就是跨域请求。

一般在前后端分离的场景，前端渲染之后，一些点击请求需要访问后端业务，这时候就会产生跨域请求。

### RestFul 是什么？RestFul 请求的 URL 有什么特点？

RestFul API 是一种接口规范，是客户端通过 url 路径访问服务端，通过 http 的方法来获取或更新资源，可以大体知道具体执行了什么操作。比如`http://www.test.com/blog`，就是用 http 协议请求`www.test.com`域名下的`/blog`路径，具体的方法是根据 http 请求中的 http 方法，如果是 post 方法，就可以理解成是发表一篇博客，get 方法就是查看博客，delete 就是删除博客，可以通过 url 和具体的方法名理解具体操作的含义。

RestFul 请求的 url 的特点是通过`/`进行分割，可以通过路径和 http 方法大致理解要执行的具体操作含义，比如`/blog/1`，用 get 方法请求，可能就是查看第一页的博客文章内容。


## HTTPS

### HTTP 和 HTTPS 有什么区别？

- HTTPS 在 TCP 三次握手之后增加了 TLS 协议的双向认证，通信的过程使用加密的方法，避免了明文传输的安全性问题；
- HTTPS 的服务端通过向 CA 申请数字证书，然后客户端从 CA 获取公钥，拿到证书计算取出服务器的公钥了；
- HTTPS 的默认监听端口是 443，HTTP 是 80。

### 了解过哪些加密算法

HTTPS 用了对称加密算法和非对称加密算法，比如 AES 和 RSA，还有 ECC 是通过椭圆曲线算法进行加密的，MD5 不可逆的加密算法。常见的还有 SHA1、SHA256、HMAC、Base64 加密算法，在一些云服务平台开发商中的请求 api 中比较常见。

### 对称加密算法和非对称加密算法的区别？

对称加密算法是客户端和服务端共用一个密钥进行加密解密，非对称加密算法是有一个公钥和私钥，比如客户端获取到服务端的公钥，服务端将要传输的信息用私钥加密，然后客户端收到信息后用公钥解密。对称加密算法的速度较快，性能较高，非对称加密算法的速度较慢，可以用来确认消息发送方的身份。

### HTTPS 建立过程是怎样的？

首先经过 TCP 三次握手之后，要进行 TLS 四次握手。TLS 握手的过程：第一次握手是客户端会发送 Client Hello，携带一个客户端随机数和 TLS 版本等信息，然后服务端会返回 ACK。接着第二次握手服务端会发送一个服务端随机数和确认客户端的 TLS 版本等信息，然后将服务端的数字证书发给客户端，然后客户端会返回 ACK。第三次握手是客户端收到数字证书后，会通过 CA 的公钥计算取出服务端的公钥，然后会再生成一个随机数用来和服务端进行非对称加密，用服务端的公钥进行加密，然后发送给服务端，服务端用私钥解密，解出来随机数，同时客户端会发送通知服务端，之后使用会话密钥进行加密通信，会话密钥通过客户端随机数、服务端随机数以及第二次交换的随机数通过对称加密得到，并且将之前发送过的内容进行摘要通过会话密钥加密发送给服务端，服务端返回 ACK。第四次是服务端以同样的操作将之前的内容进行摘要通过会话密钥加密发送给客户端，客户端返回 ACK。之后开始使用会话密钥进行加密传输。

### HTTPS 过程进行了多少次非对称加密？多少次对称加密？

非对称加密：服务端通过 CA 申请数字认证需要一次非对称加密，客户端和服务端交换一次随机数用了服务端的公钥加密、私钥解密需要一次非对称加密。总共两次。

对称加密：客户端和服务端在得到会话密钥之后会对之前发送过的内容进行摘要后加密给对方确认，这里需要两次对称加密。

HTTPS 之后的报文传输都是对称加密。

### SSL 握手过程为什么要使用非对称加密？

在建立连接的握手过程中使用非对称加密可以用来确认发送方的身份，之后传输只要用不是明文的对称加密即可，如果使用非对称速度会慢，而如果建立连接中使用了对称加密，一旦密钥泄漏，就没办法保证安全的建立连接。

### 为什么 HTTPS 不用非对称加密算法加密 HTTP 报文？

因为非对称加密报文的速度会慢，如果传输的报文过大，那么计算起来会很耗时，在建立连接的时候使用非对称加密建立了安全的连接后，之后的传输用对称加密即可。

### HTTPS 会对 URL 加密吗？

会，会对整体的报文进行加密，包括请求行、请求头、请求体

### 证书是绿色的是什么意思？

表示证书是经过 CA 机构颁发的，可信任的。

### 自己随便编一个证书可以吗？需要去什么地方注册？

不可以，自己随便编过的证书是非法的，不可信任。但是一些抓包工具会往浏览器的根证书列表中中直接导入一个证书，浏览器就默认信任了。

需要去 CA 注册。

## TCP/UDP

### 说一下 TCP 三次握手的过程

第一次握手是客户端调用 connect()，会发送一个带有初始序列号 SYN 的报文，假设为 x，然后客户端变为 SYN_Sent 状态，服务端收到后，会将连接加入到半连接队列，调用 accept() 阻塞。第二次握手，服务端会发送序列号 SYN 报文和 ACK 报文，假设序列号为 y，确认号是 x + 1，用来确认收到了客户端的初始 SYN，然后服务端进入 SYN_RECV 状态。第三次握手是客户端发送 ACK 报文，确认号是 y + 1，用来确认收到了服务端的 SYN，进入了 Establish 状态，服务端收到后，会从半连接队列中取出加入到全连接队列，accept() 返回，进入 Establish 状态，接下来客户端和服务端开始数据传输。

### 为什么需要三次握手？两次不行吗？

三次握手可以避免历史连接的建立，可以同步双方的初始序列号，避免资源的浪费，同时确保双方都有消息的发送接收能力。

首先如果是两次握手，由于客户端的初始序列号是随机生成的，如果一条旧的 SYN 报文请求到达服务端，服务端收到后返回了 ACK 和服务端的 SYN，服务端这边就进入了 Establish状态，客户端这边新的 SYN 后到达，但是收到了不是预期的 ACK 报文，这样就会返回 RST 中止连接，如果是三次握手，服务端在确认收到客户端的 ACK 后才进入 Establish 状态，同时这三次握手，客户端和服务端均有一次发送和接收的过程，双方可以确认是否具备发送和接收的能力，在互相对对方的 SYN 回复 ACK 之后，也同步了序列号。

### 如果第二次握手丢包，会发生什么？

第二次握手是服务端发送 SYN 和 ACK，如果丢包，客户端这边就不会发送第三次握手 ACK，而且客户端也收不到第一次握手的 ACK，所有客户端和服务端都会开始进行超时重传，客户端会重发第一次握手，服务端会重发第二次握手。

### 如果第三次握手丢包，会发生什么？

第三次握手是客户端发送 ACK，如果丢包，服务端这边没有收到第二次握手的 ACK，会触发超时重传，服务端会重发第二次握手。

### TCP 四次挥手的过程

假设客户端主动断开连接，调用关闭连接函数 close() 或者 shutdown()，第一次挥手会发送一个 FIN 报文，假设序号是 x，确认号是 y，客户端开始进入 FIN_WAIT_1 状态，客户端收到后，会发送第二次挥手 ACK 报文，序号是 y，确认号是 x + 1，服务端会进入 CLOSE_WAIT 状态，将没有发送完的数据发送出去，等待调用关闭连接函数，客户端进入 FIN_WAIT_2 状态。待服务端没有要处理的内容，第三次挥手会向客户端发送 FIN 报文，序号是 y，确认号是 x + 1，调用关闭连接函数，服务端进入 LAST_ACK 状态。客户端收到 FIN 报文，第四次挥手会发送 ACK 报文，序号是 x + 1，确认号是 y + 1，进入 TIME_WAIT 状态，过 2MSL 后进入 CLOSE 状态，服务端在收到客户端的 ACK 报文后进入 CLOSE 状态。

### 为什么 TCP 需要四次挥手？三次挥手不行吗？

四次挥手是让客户端和服务端将未处理完的数据处理完然后再完全关闭。

首先第一次挥手客户端调用关闭连接函数，发送 FIN 报文，表明客户端已经没有要处理发送的数据了，但是还可以接受数据，服务端在收到 FIN 后会发送一个 ACK，但这时候服务端可能还有没处理完的数据，待程序处理完后，会调用关闭连接函数，发送 FIN 报文，所以第二次和第三次挥手是分开发送，等客户端收到 FIN 报文，再发送 ACK，所以需要四次挥手。

### TIME_WAIT 是如何产生的？

只有主动关闭连接的一方才会产生 TIME_WAIT 状态，也就是在第四次挥手之后，会等待 2MSL 的时间，确保对方收到了 ACK 报文，如果服务端没有收到 ACK 会重传第三次挥手的 FIN 报文，客户端这边则要重传 ACK，那么相当于发送 ACK 和等待是否有重传的 FIN，一来一回就需要 2MSL，容许一次报文丢失，如果没有 TIME_WAIT 或者时间过短，客户端已经关闭了，那么服务端就接收不到 ACK，而且客户端收到 FIN 后会返回一个 RST 报文，虽然连接断开，但服务端会认为是出错。也防止历史连接的数据被后面相同的四元组接收，比如没有 TIME_WAIT 或者过短，旧的一个报文由于网络延时，在连接断开后马上开始新的连接建立，而旧的报文在新的建立连接后到达，如果序号正好在接收窗口内，那么会导致数据错误，所以设置 TIME_WAIT 保证还在旧的报文可以传输到被丢弃或者在网络中到了生命周期消亡。

### 服务端产生大量 CLOSE_WAIT 状态的原因是什么？

CLOSE_WAIT 是服务端收到客户端的 FIN 报文后返回 ACK 进入的状态，而进入下一个 LAST_ACK 状态，需要由服务端程序控制，服务端程序处理完之后会调用关闭连接函数，发送 FIN 报文，所以可能问题是没有正常调用关闭连接函数导致。

### 服务端产生大量 TIME_WAIT 状态的原因是什么？

主动关闭连接的一方才会有 TIME_WAIT 状态，所以是服务端主动关闭了大量的连接。可能是连接没有使用长连接，无论是客户端没有开启长连接，还是服务端没有关闭长连接，均是服务端认为连接是短链接，在发送完数据后主动关闭。也可能是长连接超时，当建立了长连接时，如果一直没有数据传送，过了时间后，服务端就会主动断开连接，所以可能是客户端的数据长时间没有被服务端接收到，从而服务端主动关闭。也可能是长连接数量已达上限，接下来的连接均是短链接或者直接关闭连接，所以均是服务端主动关闭。

### TCP 拆包沾包原因是什么？怎么解决？

由于 TCP 是面向字节流的协议，拆包的原因可能是一包的数据长度超过了 MSS，所以在传输层进行了分片。沾包的原因可能是多个包由于太小被放在一起发送。

解决的方案有：

- 在传输时固定消息的长度。发送数据的一方确定消息的长度，接收数据的一方在收到这个长度的数据后就会认为是一包。
- 传输时携带消息长度。比如 HTTP 的请求头中，可以指定 Content-Lenth，确定了请求包的长度大小。
- 指定固定分隔符。发送方和接收方确定分隔符规则，在接收到分隔符后表示接收到一包完整的消息。

### TCP 的 keepalive 了解吗？说一说它和 HTTP 的 keepalive 的区别？

TCP 中的 keepalive 是 TCP 的保活机制，表示的是一条 TCP 连接，如果没有消息传输，会发送一个探测报文，来检查对方是否还是正常建立连接的状态，如果不是，则会调用关闭连接函数关闭连接。HTTP 的 keepalive 是长连接表示，表示的是在一个 TCP 连接中传输多次请求响应。

### TCP 和 UDP 有什么区别？

- TCP 是面向字节流的协议，UDP 是面向报文的协议；
- TCP 是安全可靠的，有超时重传机制，而 UDP 不关心是否送达；
- TCP 是需要连接的，建立连接需要三次握手，UDP 是无连接的，通过连接 ID 即可发送数据；
- TCP 的报文内容要比 UDP 复杂。

### 什么时候用 TCP？什么时候用 UDP？

UDP 好在实时性，速度更快，不关心一些包的可靠性，比如音视频领域，加入其中一个包丢失了，也只是体现在某一处卡顿。而 TCP 是安全可靠的，对于需要数据的完整性的场合，比如 HTTP 请求，就需要 TCP 协议。

### UDP 怎么改造变为可靠传输？

QUIC 就是基于 UDP 实现的可靠传输协议，以 QUIC 为例：

- 在头部字段中增加序号：TCP 就是在某个序列号丢失了后会重传该序列号的报文，所以可以在头部中增加序号字段，序号是递增的，所以用 stream id + offset 来确定是哪个流哪个位置的数据，如果某个包丢失了或者某个流的某个数据丢失了，会重传一个新的序号的包，通过 stream id + offset 来定位实现重传；
- 分配独立的滑动窗口：HTTP 2.0 就有于 TCP 的原因，会产生队头阻塞，一条 TCP 上虽然可以有多个 Stream 传输，但是只要其中某个位置的包丢失了，后面的其他都会阻塞。所以 QUIC 为为每个 Stream 分配了独立的滑动窗口，某个 Stream 的包丢失了，也只会阻塞这个流，不会对其他的产生影响。
- 通过滑动窗口实现 Stream 级别的流量控制：由于每个 Stream 都有独立的滑动窗口，所以互不影响，QUIC 的窗口滑动并不像 TCP 那样在确认到了数据之后左边界才可以滑动，QUIC 在收到数据包最大偏移量改变时才会发生滑动，同时在接收且已确认顺序的数据增长超过接收窗口一半长度时，会将窗口的右边界进行移动。
- 灵活的拥塞控制：由于 QUIC 是在应用层实现，所以可以在从程序的角度去实现拥塞控制算法，而 TCP 在传输层，如果要更改拥塞控制算法，那么整体的内核和系统都要随之更改。

另外 QUIC 还可以实现更快的建立连接和网络迁移：QUIC 不像 TCP 握手需要三次握手 + TLS 四次握手，只需要一次握手确认连接 ID 即可，同时 QUIC 协议中包含了 TLS 的内容，在 TLS  v1.3 版本，可以在第一次握手中发送 TLS 的数据内容，所以只需要一个 RTT。而网络迁移，由于 QUIC 使用的是连接 ID，就算 IP 发生变动，只要连接 ID 不变，这个连接也不会发生变化。

### TCP 流量控制和拥塞控制的区别？

流量控制考虑的是客户端和服务端的发送接收能力，而拥塞控制考虑的是网络层面的传输压力。流量控制是利用通知滑动窗口的大小来控制，在接收端处理不过来，会通知减小窗口。而拥塞控制是通过，慢启动、拥塞避免、拥塞发生、快速恢复实现，在网络传输性能差时，会调节拥塞窗口大小。

### 滑动窗口怎么设计的？解决什么问题？

滑动窗口是接收方会维护一个接收窗口，发送方维护一个发送窗口。接收窗口表示接收方可以接收到的最大数据量，按照顺序前面的数据都被接收到后会开始滑动，发送方的窗口为一个发送窗口和可用窗口，发送窗口中的数据表示已发送但是未被确认，可用窗口中的数据是未发送的，待发送窗口中的前面的数据都被确认后，会进行移动。

滑动窗口可以避免由于接收端处理不过来，发送方还发送大量数据从而丢弃，而且由于窗口内的数据都确认了即可滑动，所以可以不用等前面的数据确认，可以发送窗口内后面的数据，提供发送效率。

### TCP 协议拥塞控制是怎么实现的？

拥塞控制是有一个拥塞窗口，发送窗口会取接收窗口和拥塞窗口的最小值来作为发送窗口的大小。拥塞控制的过程如下：

1. 首先是慢启动：发送方最开始的拥塞窗口以一个较小值开始，以指数形式增长，每次收到 ACK 后，窗口大小进行翻倍。
2. 然后是拥塞避免：在达到慢启动门限之后，以线性形式增长，每收到一个 ACK，窗口大小就加 1。
3. 然后是拥塞发生：在网络开始拥堵，发生超时重传后，开始进入拥塞发生，慢启动门限设置为此时拥塞窗口的一半大小。
4. 然后是快恢复：在发送方收到三个接收房发送的重复的 ACK后，表示丢包需要开始重传，此时拥塞窗口设置为慢启动门限大小 + 3，3 表示有三个 ACK 收到了，然后重传，等收到下一个包的 ACK 后，拥塞窗口设置为慢启动门限大小，再次进入拥塞避免状态。

## IP

### 交换机和路由器有什么区别？

交换机是二层网络设备，通过 MAC 地址来选择发送到的其他设备上，而路由器是三层网络设备，通过路由表中记录的 IP 地址，来选择从哪个端口发出到哪个路由或设备。

### IP 地址和 MAC 地址有什么区别？

IP 地址是网络层的概念，用来确定从哪个设备发往哪个目标设备，MAC 地址是数据链路层的概念，用来在确定在局域网中发送到哪个设备。

### NAT 是什么协议？

NAT 可以让多个私有 IP 地址共享一个公有 IP 地址，可以通过端口来区分。

### 192.168.1.100/24 中的斜杠代表什么意思？

/24 代表192.168.1.100 转换成二进制后，前 24 位是网络号，后面的是主机号。

## 网络攻击

### DNS 劫持是什么？

在访问 DNS 时，需要域名解析得到 IP 之后才能继续进行访问，DNS 劫持就是篡改了域名解析的结果，让本该解析访问真正的 IP 解析访问到了假的 IP。

### DNS 污染是什么？



### 简述 DDOS 攻击原理，如何防范它？



### TCP 中 SYN 洪水是什么？如何防止？



### 什么是 XSS 攻击？如何防止？



### 什么是 CSRF 攻击？如何防止？



### 什么是 SQL 注入攻击？如何防止？



## 网络 IO

### 说一下五种 I/O 模型



### 谈谈你对 I/O 多路复用的理解



### select、poll、epoll 有什么区别？



### select、poll、epoll 适合哪些应用场景？



### epoll ET 模式和 LT 模式有什么区别？哪一个更高效？



### epoll 是同步还是异步的？



### proactor 和 reactor 模式有什么区别？



### 零拷贝技术了解过吗？说一下原理



## RPC

