# 操作系统专项题库

（注：黄色字体为补充内容）

## 存储结构

### 为什么计算机要给储存结构分级？

操作系统的存储结构有，CPU 寄存器、CPU L1、L2、L3 级缓存、内存、硬盘，访问的速度由快到慢。之所以要分级，有以下原因：

- 考虑到成本问题，由于速度越快的存储结构需要的硬件材料成本越贵，所以分级可以权衡考虑。
- 使用阶段，CPU 正在执行的工作所需的上下文存储在 CPU 寄存器中，会更快访问，L1 中存储一些指令集和数据，L3 是多核 CPU 共享的空间，内存是暂时存放 CPU 需要的一些数据，可能会用到，而磁盘是永久存放数据的，大部分不会及时用到。所以没必要都放在一个地方。

### CPU cache L1 L2 L3 读取数据的时间量级差距有多大？

L1、L2、L3 的访问速度由快到慢，L1、L2、L3 的时间都是在 ns 量级左右，彼此之间应该是几个时钟周期和几十个时钟周期的差距。

（补充：这里看了下图解，实际的值记不住啊，这题想要考察的就是具体的时间差别吗？）

### CPU 缓存对程序性能的影响都体现在哪些方面？

- 缓存大小：如果缓存大，存储的数据和指令更多，会提高性能。
- 缓存命中率：如果命中率高，会提高性能，反之命中率低会频繁的从内存中读取。
- 预读：CPU Cache Line 会将数据预读出来，比如可能是用的是0-4k的数据，但是其后面的数据大概率被访问，CPU Cache Line 会预读出来0-16k的数据。

### 如何写 CPU 缓存友好的程序？

- 提高数据的缓存命中率：比如如下代码，

```Plain
for i := 0;i < n;i ++ {
        for j := 0;j < m;j ++ {
                        a[i][j] = ....
        }
}
for i := 0;i < n;i ++ {
        for j := 0;j < m;j ++ {
                        a[j][i] = ....
        }
}
```

第一段代码的命中率就高于第二个，因为二维数组在内存中存放是连续的形式， CPU 读取数据是也是按照顺序读取的，并且会预读，如果是`a[j][i]`，下一个数据是`a[j+1][i]`，在数据量很大时可能不会命中到。

- 提高指令的命中率：CPU 会通过分支预测将指令提前缓存，最常见的是 if else 指令，如果某个条件出现的频率高，CPU 会将其分支下的指令先缓存，可以利用这一点提高命中率。
- 避免多核 CPU 的频繁切换：程序可能在 CPU 之间来回切换执行，这时候可以让一个 CPU 绑定一个程序执行，避免切换影响性能问题。

## 内核态

### 为什么要区分内核态和用户态？内核态和用户态区别？

为什么要区分：

- 内核有很高的权限，为了避免用户直接操作内核，发生不可避免的错误；
- 内核态的代码和指令的迭代速度不如用户态这么自由，用户可以根据自己的需求发起内核调用，避免互相牵制；

区别：

- 用户态的资源和操作受到限制，内核态可以访问所有的资源和执行操作，级别更高。

补充：这里的区别我只能想到这个，就是权限和资源的限制区分，还有其他需要回答的吗？

### 什么时候会由用户态陷入内核态？

- 当发生系统调用的时候；
- 用户态触发中断；
- 用户态执行其他需要内核权限的操作。

### 系统调用的过程？

用户态发起系统调用，会触发 CPU 中断，CPU 保存当前执行程序的上下文，并使用用户态发起的请求参数，保存在寄存器、缓存、堆栈中，待程序执行完，CPU 会恢复之前之前程序的现场，然后用户态会继续执行。

补充：用户态发起系统调用，会触发 CPU 中断，中断服务程序会把用户态的上下文信息会保存在 CPU 的内核栈中，并存入 CPU 的 ss 和 rsp 寄存器中，并将用户态的栈信息存在 ss3 和 rsp3 寄存器中，待中断处理完之后，中断服务程序会把内核栈中的信息弹出，并把把 ss3 和 rsp3 的用户态栈信息存入 ss 和 rsp 寄存器中，这样就恢复了用户态的程序。（看图片后的个人理解，不知道对不对）

## 进程&线程

### 进程和线程有什么区别？

进程是操作系统资源分配的最小单位，线程是 CPU 调度的最小单位，一个进程可以创建多个线程，多个线程共享进程的资源（进程的代码段、内存空间、全局变量、堆等）。

### 为什么创建进程比创建线程慢？

因为进程的创建伴随着资源的申请、分配，而线程是共享进程的资源，只需要创建线程所需要的堆栈空间等少部分资源即可。

补充：因为创建一个进程，就会创建一个主线程。创建进程时要为其分配一段完整的内存空间，有大量的初始化操作，比如内存分段等，创建线程并不需要考虑内存空间，因为多线程是共享进程的资源，只需要考虑自己的寄存器、栈等信息，因此创建线程的开销会更少更快。

### 为什么进程的切换比线程开销大？

因为进程之间的资源都是隔离的，进程有自己的虚拟地址空间，通过页表映射到物理地址空间，而为了缓存常用的映射关系，会通过 TLB 来管理，进程的切换伴随着所有创建时的资源的切换，所以页表切换后，TLB 也就失效了，而线程共享了进程的内存空间，在切换的时候，TLB 依然有效，所以线程的切换比进程的切换时所需要变动的资源更少，开销更小。

### 协程和线程有什么区别？

协程是轻量级的线程，一个线程可以有多个协程，协程共享线程的资源。协程由用户态控制，协程的切换也是在用户态执行，相比于线程，开销更小。

补充：

- 协程之间的调度是协作式调度，协程可以在自己的时间内执行完之后，主动让出 CPU 交给其他的协程执行。go语言实现了协程的抢占式调度，在一个协程占用时间过长会让出 CPU 给其他协程使用。而线程本身就是抢占式调度，当发生中断时，CPU 会切到其他线程运行。
- 协程的切换速度更快，不涉及到用户态和内核态的切换。Go 语言中协程的切换涉及到协程自己寄存器中保存的值，而线程中涉及到自己的寄存器、栈等信息，切换的开销更大。
- 线程的栈要比协程的栈大很多，线程的栈大小在创建时指定，默认是 8M，而一个协程的大小在创建时默认是 2kb，go协程的栈空间由 runtime 管理，可以动态分配，在需要扩容时再增大。

### 进程间有哪些通信方式？哪一种效率最高？

- 管道
- 消息队列
- 信号
- 信号量
- socket
- 共享内存

其中共享内存的效率最高，共享内存的实现是通过多个进程各自独立的虚拟内存页表，映射到同一片物理内存，因为不涉及到上下文切换、用户态和内核态的切换、fork、远程调用的机制，只需要考虑竞争条件即可。（这里不确定是不是共享内存的效率最高，只是我自己的理解，但是因为它要考虑竞争条件，需要加锁，这里就是锁和用户态内核态切换、还有fork的性能比较，感觉互斥可能效率相对好一点。）

### 线程间同步方式有哪一些？

可以使用锁和信号量实现线程的同步。

锁可以在线程执行时让线程一直自旋等待，不执行其他操作，也可以让线程不自旋加入到等待队列，等待调度。其中锁分为自旋锁、互斥锁、读写锁。

信号量可以让多个线程之间，通过原子操作，实现信号量的 PV 控制，从而做到互斥同步。

### 并行和并发的区别

并行相当于两个程序一起执行，是真正意义上的并行处理，并发其实是两个程序交替执行，由于切换和执行很快，给人的感觉是并行。

## 锁

### 自旋锁和互斥锁有什么区别？什么时候用自旋锁？什么时候用互斥锁？

- 自旋锁是线程在没获取到锁的时候会一直占有 CPU 阻塞，直到获得锁。
- 互斥锁是线程没获取到锁会让出 CPU 给其他的程序执行，等待调用。

互斥锁存在两次线程的上下文切换，所以在程序执行很快的时候，不建议使用互斥锁，更推荐使用自旋锁。

### 悲观锁和乐观锁有什么区别？

悲观锁可以看作线程认为其他线程都会来竞争，所以要上锁再执行，而乐观锁则反之认为不会竞争，所以不会上锁，在执行操作后会看是否有其他线程操作过，如果有则放弃操作

### 乐观锁怎么实现？

乐观锁通过 CAS 原子操作或者版本号控制实现。CAS 的全称是 Compare And Swap，如果当前值和预期值一样，则进行修改，否则放弃操作，如果使用 CAS 可能会出现 ABA 的问题，比如，线程 1 记录下 a 的旧值，想要修改 a，但这时候有一个 线程 2，修改了 a 的值，又将 a 的值更改回原先的旧值，这样对于线程 1 来说，就满足了 CAS，但其实是不允许的，所以引入了版本号的控制。版本号是增加一个字段来表示当前版本，更新的时候也更新版本，先记录下当前版本，然后在更新的时候先比对下版本号是否一致，不一致说明其他的线程在这期间修改过，那么就放弃操作，一致的话则执行更新操作，并修改版本号。

### 操作系统死锁怎么产生的？

死锁的产生有四个条件：

- 互斥：即多个线程不能同时操作同一个资源，操作是互斥的；
- 持有并等待：线程持有了资源后，还需要获取其他资源，会一直持有手上的资源和等待其他资源的释放；
- 不可剥夺：线程持有的资源不会被其他线程抢占，具有不可剥夺行；
- 循环等待：获取资源的过程形成了一个循环，比如线程 A 获取了资源 1，现在要获取资源 2，线程 B 获取了资源 2，现在要获取资源 1。

### 如何避免出现死锁，怎么排查？

避免死锁的方法，只要破坏上述死锁产生条件中的一个就可以，由于锁要满足互斥性，所以可以从后三点来考虑，比如持有并等待和不可剥夺可以让获取资源的线程在没获取到其他资源后，可以主动释放自己的资源或者允许被抢占，循环等待可以让获取资源的顺序一致。

在 Linux 中，可以通过`pstack`与`gdb`来进行排查，通过`pstack`来查看线程的调用过程，找到一直在等待锁，阻塞卡住的线程，通过`gdb`打印出线程的堆栈信息，找到具体死锁的对象。

补充：针对go语言的死锁排查，有几种方案：

- 用 go-deadlock 包替代原生包的mutex锁，该包实现了死锁时打印goroutine的调用、数据、可能发生死锁位置等信息。
- 用 pprof 工具，在运行go程序后，用`go tool trace`命令，可以查看 goroutine 的创建、调用栈、执行的信息，可以排查加锁冲突的位置。
- 用官方的`go vet file`命令可以排查一下可能出现的死锁代码。

## 内存管理

### 为什么操作系统会有虚拟内存？

每个进程都有自己的虚拟内存页，通过一一映射的关系对应到物理内存，让进程不直接去操作物理内存，这样可以减少进程之间共享内存的开销，将进程之间隔离开，简化内存的管理。

补充：

- 虚拟内存可以让程序运行超过物理内存的大小，因为程序的运行符合局部性原理，对于没有经常访问到的程序，可以通过 SWAP 机制换到磁盘，等使用的时候再换入。
- 每个进程有自己的页表，从而虚拟内存空间的独立的，这样解决了多进程地址冲突的问题。
- 页表中除了物理内存地址外，还有一些属性标志位，比如权限标识，提高了安全性。

### 数组的物理空间连续吗？

不一定连续，因为内存是以分页的形式切分，如果数组的长度超过了一页的大小，Linux 中是 4k，就会分配在另一页上，可能会不连续。

### 进程的虚拟内存的布局是怎么样的？

首先，32 位操作系统可以表示 4G 的地址空间，其中 3G 在用户态，1G 在内核态，而 64 位操作系统能表示的就是 2^64 的地址空间，其中内核态和用户态的空间大小均为 128T，中间的空间留白。如果采用多级页表的形式，一个虚拟空间地址会记录下每一级的页表和偏移量，然后通过页表找到物理页号，再加上偏移量找到具体的物理空间地址。用户态的虚拟内存主要存代码段、堆栈段、数据段、BSS段、文件映射段。 

### 堆区和栈区的区别

- 堆的空间是由用户手动分配，而栈的空间是自动分配的；
- 栈的空间会被自动垃圾回收，堆的不会，堆的需要手动释放；
- 栈空间较小，堆的空间较大；
- 栈存的内容一般是局部变量、局部参数，不会被外部调用而一直存在的数据，而堆中一般存放指针、全局等一些一直使用的数据；
- 栈分配和申请的速度比堆快。

### 在栈上的数据操作比堆上快很多的原因？

栈中存放的对象都是局部变量和参数，可以直接使用，堆中存放的指针、引用等需要再去寻址访问，所以栈的速度要快。

补充：栈中的数据的地址空间是连续的，可以利用 CPU Cache 的预读功能提高缓存命中率，起到加速的效果，而堆上的地址空间是不连续的，所以栈会更快一些。

### fork 的写时复制是如何实现的？

当父进程`fork()`一个子进程，子进程会复制一份父进程的页表，父子进程的页表指向同一片物理内存，所以父子进程会共享内存，不会立刻进行写时复制，当对于内存中的数据进行修改后，才会发生复制，会复制一份修改的数据的物理内存，然后页表重新映射到该物理内存上，而且只复制修改的那份数据页。（这里是和 redis aof 的那个写时复制一样吧，只复制修改过的数据？）

## Linux 命令

### Linux 怎么查看 CPU 利用率？

可以用`top`命令实时查看每一个进程的 CPU 使用率

### Linux top 命令展示了哪些信息？

`top`命令展示了进程的 pid、执行时间、进程任务状态、CPU 利用率、内存使用、系统的负载情况等信息

### Linux 下如何查看端口被哪个进程占用？

补充：通过`netstat -napt | grep 端口号`查看。（实际中没有用过太多 Linux 命令，没什么经验。）

### Linux 系统 CPU 100% 怎么排查？

首先可以通过`top`命令查看占用 CPU 过高的进程，确认是哪个进程之后，`top -H -p pid`找到找到占用资源过多的线程，可以通过`pstack`和`gdb`查看线程的堆栈信息，

补充：针对go语言的死锁排查，有几种方案：

- 用 go-deadlock 包替代原生包的mutex锁，该包实现了死锁时打印goroutine的调用、数据、可能发生死锁位置等信息。
- 用 pprof 工具，在运行go程序后，用`go tool trace`命令，可以查看 goroutine 的创建、调用栈、执行的信息，可以排查加锁冲突的位置。
- 用官方的`go vet file`命令可以排查一下可能出现的死锁代码。

### 查找一个字符串是否在文件中

可以通过`grep 'xxx' file`查看`xxx`是否在 file 文件中
