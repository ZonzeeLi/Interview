# 操作系统专项题库

## 存储结构

### 为什么计算机要给储存结构分级？

操作系统的存储结构有，CPU 寄存器、CPU L1、L2、L3 级缓存、内存、硬盘，访问的速度由快到慢。之所以要分级，有以下原因：

- 考虑到成本问题，由于速度越快的存储结构需要的硬件材料成本越贵，所以分级可以权衡考虑。
- 使用阶段，CPU 正在执行的工作所需的上下文存储在 CPU 寄存器中，会更快访问，L1 中存储一些指令集和数据，L3 是多核 CPU 共享的空间，内存是暂时存放 CPU 需要的一些数据，可能会用到，而磁盘是永久存放数据的，大部分不会及时用到。所以没必要都放在一个地方。

### CPU cache L1 L2 L3 读取数据的时间量级差距有多大？

L1、L2、L3 的访问速度由快到慢，L1、L2、L3 的时间都是在 ns 量级左右，彼此之间应该是几个时钟周期和几十个时钟周期的差距。

### CPU 缓存对程序性能的影响都体现在哪些方面？

- 缓存大小：如果缓存大，存储的数据和指令更多，会提高性能。
- 缓存命中率：如果命中率高，会提高性能，反之命中率低会频繁的从内存中读取。
- 预读：CPU Cache Line 会将数据预读出来，比如可能是用的是0-4k的数据，但是其后面的数据大概率被访问，CPU Cache Line 会预读出来0-16k的数据。

### 如何写 CPU 缓存友好的程序？

- 提高数据的缓存命中率：比如如下代码，

```
for i := 0;i < n;i ++ {
	for j := 0;j < m;j ++ {
			a[i][j] = ....
	}
}
```

```
for i := 0;i < n;i ++ {
	for j := 0;j < m;j ++ {
			a[j][i] = ....
	}
}
```

第一段代码的命中率就高于第二个，因为二维数组在内存中存放是连续的形式， CPU 读取数据是也是按照顺序读取的，并且会预读，如果是`a[j][i]`，下一个数据是`a[j+1][i]`，在数据量很大时可能不会命中到。

- 提高指令的命中率：CPU 会通过分支预测将指令提前缓存，最常见的是 if else 指令，如果某个条件出现的频率高，CPU 会将其分支下的指令先缓存，可以利用这一点提高命中率。
- 避免多核 CPU 的频繁切换：程序可能在 CPU 之间来回切换执行，这时候可以让一个 CPU 绑定一个程序执行，避免切换影响性能问题。

## 内核态

### 为什么要区分内核态和用户态？内核态和用户态区别？

为什么要区分：

- 内核有很高的权限，为了避免用户直接操作内核，发生不可避免的错误；
- 内核态的代码和指令的迭代速度不如用户态这么自由，用户可以根据自己的需求发起内核调用，避免互相牵制；

区别：

- 用户态的资源和操作受到限制，内核态可以访问所有的资源和执行操作，级别更高。

### 什么时候会由用户态陷入内核态？

- 当发生系统调用的时候；
- 用户态触发中断；
- 用户态执行其他需要内核权限的操作。

### 系统调用的过程？

用户态发起系统调用，会触发 CPU 中断，CPU 保存当前执行程序的上下文，并使用用户态发起的请求参数，保存在寄存器、缓存、堆栈中，待程序执行完，CPU 会恢复之前之前程序的现场，然后用户态会继续执行。

## 进程&线程

### 进程和线程有什么区别？

进程是操作系统资源分配的最小单位，线程是 CPU 调度的最小单位，一个进程可以创建多个线程，多个线程共享进程的资源，

### 为什么创建进程比创建线程慢？

因为进程的创建伴随着资源的申请、分配，而线程是共享进程的资源，只需要创建线程所需要的堆栈空间等少部分资源即可。

### 为什么进程的切换比线程开销大？

因为进程之间的资源都是隔离的，进程的切换伴随着所有创建时的资源的切换，而线程共享了一部分进程的资源，所以线程的切换比进程的切换时所需要变动的资源更少，开销更小。

### 协程和线程有什么区别？

协程是轻量级的线程，一个线程可以有多个协程，协程共享线程的资源。协程由用户态控制，协程的切换也是在用户态执行，相比于线程，开销更小。

### 进程间有哪些通信方式？哪一种效率最高？

- 管道
- 消息队列
- 信号
- 信号量
- socket
- 共享内存

其中共享内存的效率最高，因为不涉及到上下文切换、用户态和内核态的切换、fork、远程调用的机制，只需要考虑竞争条件即可。

### 线程间同步方式有哪一些？

可以使用锁和信号量实现线程的同步。

锁可以在线程执行时让线程一直自旋等待，不执行其他操作，也可以让线程不自旋加入到等待队列，等待调度。

信号量可以让多个线程之间，通过原子操作，实现信号量的 PV 控制，从而做到互斥同步。

### 并行和并发的区别

并行相当于两个程序一起执行，是真正意义上的并行处理，并发其实是两个程序交替执行，由于切换和执行很快，给人的感觉是并行。

## 锁

### 自旋锁和互斥锁有什么区别？什么时候用自旋锁？什么时候用互斥锁？

- 自旋锁是线程在没获取到锁的时候会一直占有 CPU 阻塞，直到获得锁。
- 互斥锁是线程没获取到锁会让出 CPU 给其他的程序执行，等待调用。

互斥锁存在两次线程的上下文切换，所以在程序执行很快的时候，不建议使用互斥锁，更推荐使用自旋锁。

### 悲观锁和乐观锁有什么区别？

悲观锁可以看作线程认为其他线程都会来竞争，所以要上锁再执行，而乐观锁则反之认为不会竞争，所以不会上锁，在执行操作后会看是否有其他线程操作过，如果有则放弃操作

### 乐观锁怎么实现？

乐观锁通过 CAS 原子操作或者版本号控制实现。CAS 的全称是 Compare And Swap，如果当前值和预期值一样，则进行修改，否则放弃操作；版本号是增加一个字段来表示当前版本，更新的时候也更新版本，先记录下当前版本，然后在更新的时候先比对下版本号是否一致，不一致说明其他的线程在这期间修改过，那么就放弃操作，一致的话则执行更新操作，并修改版本号。

### 操作系统死锁怎么产生的？

死锁的产生有四个条件：

- 互斥：即多个线程不能同时操作同一个资源，操作是互斥的；
- 持有并等待：线程持有了资源后，还需要获取其他资源，会一直持有手上的资源和等待其他资源的释放；
- 不可剥夺：线程持有的资源不会被其他线程抢占，具有不可剥夺行；
- 循环等待：获取资源的过程形成了一个循环，比如线程 A 获取了资源 1，现在要获取资源 2，线程 B 获取了资源 2，现在要获取资源 1。

### 如何避免出现死锁，怎么排查？

避免死锁的方法，只要破坏上述死锁产生条件中的一个就可以，由于锁要满足互斥性，所以可以从后三点来考虑，比如持有并等待和不可剥夺可以让获取资源的线程在没获取到其他资源后，可以主动释放自己的资源或者允许被抢占，循环等待可以让获取资源的顺序一致。

在 Linux 中，可以通过`pstack`与`gdb`来进行排查，通过`pstack`来查看线程的调用过程，找到一直在等待锁，阻塞卡住的线程，通过`gdb`打印出线程的堆栈信息，找到具体死锁的对象。

## 内存管理

### 为什么操作系统会有虚拟内存？

每个进程都有自己的虚拟内存页，通过一一映射的关系对应到物理内存，让进程不直接去操作物理内存，这样可以减少进程之间共享内存的开销，将进程之间隔离开，简化内存的管理。

### 数组的物理空间连续吗？

不一定连续，因为内存是以分页的形式切分，如果数组的长度超过了一页的大小，Linux 中是 4k，就会分配在另一页上，可能会不连续。

### 进程的虚拟内存的布局是怎么样的？

首先，32 位操作系统可以表示 4G 的地址空间，其中 3G 在用户态，1G 在内核态，而 64 位操作系统能表示的就是 2^64 的地址空间，其中内核态和用户态的空间大小均为 128T，中间的空间留白。如果采用多级页表的形式，一个虚拟空间地址会记录下每一级的页表和偏移量，然后通过页表找到物理页号，再加上偏移量找到具体的物理空间地址。用户态的虚拟内存主要存代码段、堆栈段、数据段、BSS段、文件映射段。 

### 堆区和栈区的区别

- 堆的空间是由用户手动分配，而栈的空间是自动分配的；
- 栈的空间会被自动垃圾回收，堆的不会，堆的需要手动释放；
- 栈空间较小，堆的空间较大；
- 栈存的内容一般是局部变量、局部参数，不会被外部调用而一直存在的数据，而堆中一般存放指针、全局等一些一直使用的数据；
- 栈分配和申请的速度比堆快。

### 在栈上的数据操作比堆上快很多的原因？

栈中存放的对象都是局部变量和参数，可以直接使用，堆中存放的指针、引用等需要再去寻址访问，所以栈的速度要快。

### fork 的写时复制是如何实现的？

当父进程`fork()`一个子进程，父子进程共享内存页，不会立刻复制，当对于内存中的数据进行修改后，才会发生复制，而且只复制修改的那份数据页。

## Linux 命令

### Linux 怎么查看 CPU 利用率？

可以用`top`命令实时查看每一个进程的 CPU 使用率

### Linux top 命令展示了哪些信息？

`top`命令展示了进程的 pid、执行时间、进程任务状态、CPU 利用率、内存使用等信息

### Linux 下如何查看端口被哪个进程占用？

### Linux 系统 CPU 100% 怎么排查？

首先可以通过`top`命令查看占用 CPU 过高的进程，确认是哪个进程之后，`top -H -p pid`找到找到占用资源过多的线程，可以通过`pstack`和`gdb`查看线程的堆栈信息，

### 查找一个字符串是否在文件中

可以通过`grep 'xxx' file`查看`xxx`是否在 file 文件中