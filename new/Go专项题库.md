# Go 专项题库

## 基础相关

### 相比较于其他语言, Go 有什么优势或者特点？

相对于 Java 和 C++，Go 语言的的编译速度快、高并发性能好，部署更简单。

### golang 中 make 和 new 的区别？（基本必问）

- make 返回具体的类型 type，而 new 返回类型指针 *type；
- make 可以初始化内存，而 new不行，new 分配的内存是对应类型的零值；
- make 只能给 slice、channel、map 使用。new 可以任何类型。

### 数组和切片的区别 （基本必问），切片怎么扩容

- 数组是 arrary，而切片是 slice，它的数据结构是指向一个底层数组 arrary 的指针、len 长度、cap 容量；
- 数组是固定长度的，切片是可以扩容，追加元素的；
- 如果数组作为传参，由于值传递，不会影响原数组，如果是切片作为传参，虽然是值传递，但是切片的数据结构是引用底层数组，所以会影响原切片。

切片的扩容方式在 1.17 之前：

- 如果期望容量大于当前容量的两倍就会使用期望容量；
- 如果当前切片的容量小于 1024 就会翻倍；
- 如果当前切片的容量大于 1024 就会么次增长 25 % 的容量，直到当前容量大于期望容量。

在 1.17 之后：

- 如果期望容量大于当前容量的两倍就会使用期望容量；
- 如果当前切片的容量小于 256 就会翻倍；
- 如果当前切片的容量大于 256 会按照公式`new = old + (old + 3*256)/4`扩容，直到大于期望容量。

### for range 的时候它的地址会发生变化么？

不会发生变化，比如`for _, v := range []slice{}`，这里的`v`的地址一直是同一个，在遍历的时候，将切片内的元素每次遍历到都赋值给这个`v`。

###  for range 循环遍历 slice 有什么问题？

- 无法获取到 slice 的每个元素的地址；
- for range 在遍历的时候已经确定了通过 slice 的长度确定了遍历次数，如果这时候增加了 slice 的长度，无法遍历到新元素；
- for range 会对遍历的对象复制一份，如果是过大的 slice 会有性能问题。

### go defer，多个 defer 的顺序，defer 在什么时机会修改返回值？（defer 和 return）

defer 的执行顺序是从下依次向上执行。如果 defer 在 return 设置返回值之后对于返回值有修改，则会影响返回值。

### uint 类型溢出

举两个例子：

```go
func main() {
	var a uint8 = 255
  var b uint8 = 1
  fmt.Println(a+b) // 0
}
```

由于是 uint8 表示，结果也是 uint8 类型，占用一个字节，8 位，正常结果是 256，按照 uint8 来分析，就是 0。

```go
func main() {
	var a uint = 0
	var b uint = 1
	fmt.Println(a-b)
}
```

由于是 uint 类型，结果也是 uint，上面的计算可以看成 0 + (-1)，计算机的负数是以补码的形式计算，所以以 uint 类型来看，如果是 32 位操作系统，那么就是 2^32 - 1，如果是 64 位操作系统，就是 2^64 - 1。

### 介绍 rune 类型

rune 类型在某种程度上是和 int 32 等价的，但是 rune 适用于字符长度，是采用 UTF-8 编码的，如果计算中文字符的长度，使用 int32 记录的是字节长度。

### Go中两个Nil可能不相等吗？

可能，接口类型包含类型和值，必须要两个全满足才相等，如果接口类型和非接口类型的nil比较，那么结果可能不相同。

### golang 中解析 tag 是怎么实现的？反射原理是什么？(问的很少，但是代码中用的多)

go 语言中的 tag 是通过反射来获取的，通过反射获取结构体变量的所有元素，每一个字段的所有内容是一个 field，通过 field 的信息，可以通过 get 获取到所有 tag 的值。

go 语言的反射是通过接口类型实现，通过隐式转换，将其他类型转换成 interface 类型，再从 interface 类型转换成反射类型，然后可以获取到每个 field 的值。

### go struct 能不能比较？

- 必须是同类型的 struct 才可以比较；
- 如果 struct 中包含 slice、map、channel，则无法比较。

### 结构体打印时，%v 和 %+v 的区别

%v 可以打印出全部元素值，%+v可以打印出全部字段和元素值。

### 空 struct{} 占用空间么？

空结构体不占据内存空间。

### go语言中空 struct{} 的用途？

1. 可以作为 channel 的数据，通常用来作为信号量来进行通知；
2. 可以作为 map 的 value 标识，代表当前 key 存在。

### go中 "_" 的作用

1. 可以代表不需要结果值，比如`_ = funcA()`，表示我们执行`funcA()`但是却对其返回值不关心；
2. 在 import 中，表示只需要执行该包下的 init 函数，比如`import _ "mysql/driver"。

### Go 闭包

go 语言支持匿名函数，匿名函数就可以作为闭包，闭包可以理解为一个函数内部的函数，内部函数的环境是外部函数提供的。

### Go 多返回值怎么实现的？




### Go 语言中不能比较的类型如何比较是否相等？

可以利用反射的`reflect.DeepEqual`来比较，将其他类型转换成反射类型进行深度比较。

###  Go 中 init 函数的特征?

1. 会在函数启动后先执行；
2. 会按照包引用的层级顺序，从最底层开始向上执行；
3. 同一个包下，会按照文件名顺序执行。

### Go 中 uintptr 和 unsafe.Pointer 的区别？

1. uintptr 可以进行算数运算，unsafe.Pointer 不能；
2. unsafe.Pointer 是指针对象，而 uintptr 其实是 uint；
3. GC 可以通过 unsafe.Pointer 防止活跃对象被回收或者扫描到更多的活跃对象，而 uintptr 是 uint，该对象可以被回收掉。

## Context 相关

### context 结构是什么样的？

context 是一个接口，提供了`Value()`、`Err()`、`Done()`、`Deadline()`四种方法。

### context 使用场景和用途？（基本必问）

1. 用作控制子 goroutine 的关闭，比如可以通过父 goroutine 的 context 创建子 context，通过取消信号、超时时间等来控制关闭；
2. 可以作为上下文信息，传递一些共享信息，比如session、token、traceid。

## Channel 相关

### channel 是否线程安全？锁用在什么地方？

channel 是线程安全的，channel 的底层数据结构是一个循环队列，结构体包含一个互斥锁，在队列中写入和读出的操作时，要先加互斥锁。

### go channel 的底层实现原理 （数据结构）

channel 的底层结构是一个指向循环队列的指针，记录了循环队列的参数，而且包含两个等待队列，一个是发送数据的 goroutine 放到 sendq 这个等待队列，接收数据的 goroutine 会放到 recvq 这个队列，结构体包含一个互斥锁，在队列中写入和读出的操作时，要先加互斥锁。

### nil、关闭的 channel、有数据的 channel，再进行读、写、关闭会怎么样？（各类变种题型）

- nil：读会死锁，写会死锁，关闭会 panic；
- 关闭的 channel；读如果有数据会读完，如果没有数据会读到 0 值，写会 panic，关闭会 panic；
- 有数据的 channel；读会读到数据，写如果缓冲区满了会阻塞，不然会写入成功，关闭会正常关闭。

### 向 channel 发送数据和从 channel 读数据的流程是什么样的？

- 发：如果 channel 的 recvq 队列中有正在等待读的 goroutine，会唤醒第一个并直接将数据发送过去，否则如果循环队列没有满会写入到循环队列的队尾，如果满了会将发送的 goroutine 写入 sendq 队列阻塞。
- 读：如果 channel 的 sendq 队列中有正在等待发送的 goroutine，如果 channel 是无缓冲的，则会唤醒第一个并直接将数据读取，如果是有缓冲的，由于 sendq 队列中存在正在等待发送的 goroutien，说明当前循环队列已经满了，则会将队首的元素发给接收的 goroutine 读取，并且会唤醒第一个 sendq 队列的 goroutine，将发送的数据写入到队尾，如果 sendq 队列中没有等待发送到的 goroutine，如果循环队列中有元素，会将队首的元素发送给接收的 goroutine 读取，如果没有，则会将读取的 goroutine 写入 recvq 队列阻塞。

## Map 相关

### map 使用注意的点，并发安全？

Map 是并发不安全的，如果多个 goroutine 同时对同一个 map 进行并发读写，会发生竞争错误。

### map 循环是有序的还是无序的？

无序的，每次遍历会从随机序号的桶，再从随机槽位开始遍历。

### 为什么go语言的map要这样设计，要随机选定桶号和槽位进行随机遍历？

因为 map 会发生动态扩容，如果发生扩容且发生了 key 的搬迁，那么 key 的位置可能发生变化，根据 hash 计算的后 B 位，比如原先的 B 是 3，后 B 位是“010”，如果 扩容到了 B 为 4，那么后 B 位可能是“1010”，就发生了搬迁，key 不在同一位置，这样就没有必要做成有序的设计，所以默认是无序的。

### map 如何顺序读取？

如果要顺序读取 map 的值，我们可以用一个 slice 记录下所有的 key，然后按照我们想要的顺序排序，通过遍历 slice，从 map 中获取值。

### map 中删除一个 key，它的内存会释放么？

不会释放，会将 key 的位置滞空，在达到一定阈值的时候，会进行扩容重排，减少内存碎片化。

### 怎么处理对 map 进行并发访问？有没有其他方案？ 区别是什么？

主要有两种方案，一种是加锁，一种是 sync.Map。sync.Map 的读相比 map + 锁的方案进行了优化，底层其实是两个 map，一个 read map 和一个 write map，可以无锁访问 read map，优先使用 read map，所以减少了加锁的频率，适合读多写少的场景，在写多的场景下，由于 read map 缓存失效，性能会急剧下降。

### nil map 和空 map 有何不同？

nil map 是未初始化，没有办法添加值，空 map 是分配了空间，没有任何 key 的 map，可以正常使用。

### map 的数据结构是什么？是怎么实现扩容？

map 的底层数据结构是 hmap，主要的字段有一个字段 B，由 2^B 表示桶数，其中有一个 buckets 指针指向 bmap 的数组，另外一个 oldbuckets 也是指向 bmap 的数组，用来在扩容到的时候使用，还有一个 extra 指向溢出桶的指针，其中每一个 bmap 主要是由 tophash、key、value、溢出桶指针组成，一个 bmap 可以存放 8 对 kv，tophash 是用来快速判断对应槽位的 key 是否存在。

map 的扩容触发条件有两种，一种是当 map 元素个数 / 桶个数 大于 6.5，会触发双倍扩容，另一种是溢出桶太多了，触发了等量扩容，在桶的数量小于 2^15，如果溢出桶大于桶总数，则认为溢出桶过多，如果桶总数大于 2^15，如果溢出桶大于等于 2^15，则认为溢出桶过多。

双倍扩容会新创建一个 buckets 数组，然后 oldbuckets 指向原先的 buckets，等量扩容是重新进行一次 map 中的元素搬迁，比如 delete key 并不会释放内存，而是置空，这样有可能会有碎片化的松散排列，等量扩容就是将这些分散的 kv 变得更紧凑。

扩容并不是一次全部扩容，而是渐进式扩容，在进行一次对 key 的操作，会对其 bucket 进行搬迁，同时会附带一个 bucket 搬迁。

### map 的 key 为什么得是可比较类型的？

由于要通过 map 的 key 计算哈希值，通过高 8 位和 tophash 比对，如果比对失败，说明一定不存在在桶中，如果比对成功则不一定，后 B 位来判断存放在哪个桶，而且通过具体的 hash 值可以判断是否存在哈希冲突，如果哈希冲突会向下找空位置插入，如果都满了会存放在溢出桶中，所以需要可以进行比较的类型。

## sync.Map

### read map 什么时候会更新？

- sync.Map 会优先对 read map 操作，如果 read map 中有的话，则优先更新 read map 中的元素；
- 如果不在的话，去操作 dirty，会将一个 misses 值加1，当 misses 值大于等于 dirty 的长度，会触发更新，将 dirty 复制给 read map，然后 dirty 置空，misses 置 0。

### dirty map 什么时候会更新？

- 对于 read map 中没有的数据进行更新，会操作 dirty map；
- 当 misses 值大于等于 dirty 的长度，会触发更新，dirty 会复制给 read map，然后 dirty 置空；
- 当 dirty 为 nil 的时候，如果插入一个 key，dirty 会将 read map 中非 expunged 状态的 kv 复制给 dirty。

### read map 和 dirty map的删除逻辑又什么区别？

read map 中存在，则直接将 p 标记为 nil，dirty 中存在或不存在均不需要操作，因为read map 和 dirty map 指向的是同一个，这只是软删除。等待 dirty 提升为 read 的时候，会将 dirty 复制给 read，dirty 置空，等再有 store 操作，会将 dirty 重塑，这时候会将 read 中 的非 expunged 和 非 nil 的复制给 dirty，才做到了真正的删除。 

### 那既然在删除read的时候没有删除这个key，而dirty覆盖的时候又只覆盖了read，那么加入dirty中也存在这个key，这个key是不是会被遗漏，没有删掉，导致内存泄漏？

不会，等第一轮 dirty 提升为 read 的时候，dirty 就会置空，在 dirty 重塑的时候，算真正的删除，等下一次 dirty 提升为 read 的时候，read 中的这些值就不在了。

### sync.Map中的read和dirty有什么关系？

dirty 中的 key 除了 p 为 nil 状态，其余记录了 sync.Map 中全部有效的 key，而 read 中的 key 的 p 还有一个 expunged 状态，其标记了在 dirty 中真正删除了的 key。在 store 时，如果 read 中不存在，会讲 misses +1，当 misses 达到了 dirty 的长度，会将 dirty 提升为 read， 置空，再有 store 一个新的 key 时，dirty 为空，会重塑 dirty ，将 read 中非 expunged 和非 nil 的元素复制。

### sync.Map中的值是否一定是有效的

不一定，dirty 中的 p 存在 nil 状态，只是软删除，read 中的 p 还存在 nil 和 expunged 状态，均表示标记删除，expunged 状态表示在 dirty 中真正的被删除了。

### sync.Map 应用场景

由于 sync.Map 中使用了两个 map，优先使用 read map，可以无锁访问，所以适合读多写少的场景，而 dirty 要加锁，所以在写操作突然增大时会性能急剧下降。

## GMP 相关

### 什么是 GMP？（必问）调度过程是什么样的？（对流程熟悉，要求更高，问的较少）

GMP 是 go 语言的调度模型，G 是 goroutine，M 是 machine 代表内核线程，P 是 Processer 代表逻辑处理器。

调度过程是一个 M 绑定一个 P，P 中有本地队列，包含 goroutine，go 语言的调度器会将 G 调度到 M 上运行，如果有新创建的 G 会放到 P 的本地队列中，当一个正在被 M 执行的 G 执行结束后，会发生切换，如果有多个 G 创建超过了 P 的本地队列的长度，会将本地队列中的前一半和当前创建的 G 放入到全局队列中。当创建新的 G，运行的 G 会尝试去唤醒空闲的 M 绑定 P，如果唤醒的 M 的 P 的本地队列中没有 G，会进入自旋状态，尝试从全局队列中获取 G，如果全局队列中。另外可能发生运行的 G 阻塞导致 M 阻塞，这时候 P 会去寻找空闲的其他 M 继续执行，等原先阻塞的 M 恢复了，会优先寻找原先的 P，没有找到该 M 会进入空闲队列，G 会进入全局队列。

### P和M的创建时机

- P：可以通过 GOMAXPROC 配置创建 P 的最大数量，然后运行时会创建该数量的 P；
- M：一个 P 会绑定一个 M，如果当前没有空闲的 M，就回去创建新的 M。

### 协程上下文切换过程

每一个 M 在创建时都绑定一个 G0，用来调度其他的 G 到 M 上执行，协程的切换是通过 G 和 G0 之间的切换完成的，上下文保存在 G 中，用来恢复上一次执行到哪然后继续执行。

### 调度策略

优先会在本地队列中找待执行的 G，如果没有会去全局队列中寻找，如果全局队列中也没有空闲的 G，会去抢占其他 P 的 G。

### 调度模式

抢占式和协作式。协作式是被调度房主动弃权，抢占式是强制触发被调度方中断。

### 




